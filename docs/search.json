[
  {
    "objectID": "mp02.html",
    "href": "mp02.html",
    "title": "Proposing a Successful Film",
    "section": "",
    "text": "This project uses data made available by Internet Movie Database (IMDb). While I did intially use the full data set in my analysis, I switched over to using a sub-sampled pre-processed data because my computer was struggling to handle the full data.\n\nlibrary(tidyverse)\nlibrary(dplyr)\nlibrary(tidyr)\nlibrary(ggplot2)\nlibrary(gt)\n\nget_imdb_file &lt;- function(fname){\n  fname_ext &lt;- paste0(fname, \".csv.zip\")\n  as.data.frame(readr::read_csv(fname_ext, lazy=FALSE))\n}\n\nNAME_BASICS &lt;- get_imdb_file(\"name_basics_small\")\nTITLE_BASICS     &lt;- get_imdb_file(\"title_basics_small\")\nTITLE_EPISODES &lt;- get_imdb_file(\"title_episodes_small\")\nTITLE_RATINGS &lt;- get_imdb_file(\"title_ratings_small\")\nTITLE_CREW &lt;- get_imdb_file(\"title_crew_small\")\nTITLE_PRINCIPALS &lt;- get_imdb_file(\"title_principals_small\")\n\nBelow, I am converting the birth year and death year to numeric data types.\n\nNAME_BASICS &lt;- NAME_BASICS |&gt;\n  mutate(birthYear = as.numeric(birthYear), # numeric birth years\n         deathYear = as.numeric(deathYear))\n\nWith that, the data I am using has been narrowed down significantly to a smaller and manageable sub sample.\n\n\n\n\nDisplay Code\nlibrary(DT)\nlibrary(dplyr)\n\nsample_n(NAME_BASICS, 1000) |&gt;\n  DT::datatable()\n\n\n\n\n\n\n\n\n\n\n\nDisplay Code\nsample_n(TITLE_BASICS, 1000) |&gt;\n  DT::datatable()\n\n\n\n\n\n\n\n\n\n\n\nDisplay Code\nsample_n(TITLE_CREW, 1000) |&gt;\n  DT::datatable()\n\n\n\n\n\n\n\n\n\n\n\nDisplay Code\nsample_n(TITLE_EPISODES, 1000) |&gt;\n  DT::datatable()\n\n\n\n\n\n\n\n\n\n\n\nDisplay Code\nsample_n(TITLE_RATINGS, 1000) |&gt;\n  DT::datatable()\n\n\n\n\n\n\n\n\n\n\n\nDisplay Code\nsample_n(TITLE_PRINCIPALS, 1000) |&gt;\n  DT::datatable()"
  },
  {
    "objectID": "mp02.html#data",
    "href": "mp02.html#data",
    "title": "Proposing a Successful Film",
    "section": "",
    "text": "This project uses data made available by Internet Movie Database (IMDb). While I did intially use the full data set in my analysis, I switched over to using a sub-sampled pre-processed data because my computer was struggling to handle the full data.\n\nlibrary(tidyverse)\nlibrary(dplyr)\nlibrary(tidyr)\nlibrary(ggplot2)\nlibrary(gt)\n\nget_imdb_file &lt;- function(fname){\n  fname_ext &lt;- paste0(fname, \".csv.zip\")\n  as.data.frame(readr::read_csv(fname_ext, lazy=FALSE))\n}\n\nNAME_BASICS &lt;- get_imdb_file(\"name_basics_small\")\nTITLE_BASICS     &lt;- get_imdb_file(\"title_basics_small\")\nTITLE_EPISODES &lt;- get_imdb_file(\"title_episodes_small\")\nTITLE_RATINGS &lt;- get_imdb_file(\"title_ratings_small\")\nTITLE_CREW &lt;- get_imdb_file(\"title_crew_small\")\nTITLE_PRINCIPALS &lt;- get_imdb_file(\"title_principals_small\")\n\nBelow, I am converting the birth year and death year to numeric data types.\n\nNAME_BASICS &lt;- NAME_BASICS |&gt;\n  mutate(birthYear = as.numeric(birthYear), # numeric birth years\n         deathYear = as.numeric(deathYear))\n\nWith that, the data I am using has been narrowed down significantly to a smaller and manageable sub sample.\n\n\n\n\nDisplay Code\nlibrary(DT)\nlibrary(dplyr)\n\nsample_n(NAME_BASICS, 1000) |&gt;\n  DT::datatable()\n\n\n\n\n\n\n\n\n\n\n\nDisplay Code\nsample_n(TITLE_BASICS, 1000) |&gt;\n  DT::datatable()\n\n\n\n\n\n\n\n\n\n\n\nDisplay Code\nsample_n(TITLE_CREW, 1000) |&gt;\n  DT::datatable()\n\n\n\n\n\n\n\n\n\n\n\nDisplay Code\nsample_n(TITLE_EPISODES, 1000) |&gt;\n  DT::datatable()\n\n\n\n\n\n\n\n\n\n\n\nDisplay Code\nsample_n(TITLE_RATINGS, 1000) |&gt;\n  DT::datatable()\n\n\n\n\n\n\n\n\n\n\n\nDisplay Code\nsample_n(TITLE_PRINCIPALS, 1000) |&gt;\n  DT::datatable()"
  },
  {
    "objectID": "mp02.html#preliminary-exploration",
    "href": "mp02.html#preliminary-exploration",
    "title": "Proposing a Successful Film",
    "section": "Preliminary Exploration",
    "text": "Preliminary Exploration\n1. How many movies are in our data set? How many TV series? How many TV episodes?\n\n\nDisplay Code\nlibrary(gt)\nTITLE_BASICS |&gt;\n  group_by(titleType) |&gt;\n  filter(titleType %in% c(\"movie\", \"tvSeries\", \"tvEpisode\" )) |&gt;\n  summarise(count = n()) |&gt;\n  gt() |&gt; # create a display table\n  tab_header(\n    title = \"Number of Title Types\"\n  ) |&gt;\n  cols_label( # display column names\n    titleType = \"Type\",\n    count = \"Count\"\n  )\n\n\n\n\n\n\n\n\nNumber of Title Types\n\n\nType\nCount\n\n\n\n\nmovie\n131662\n\n\ntvEpisode\n155722\n\n\ntvSeries\n29789\n\n\n\n\n\n\n\n2. Who is the oldest living person in our data set?\n\n\nDisplay Code\nNAME_BASICS |&gt; \n  filter(is.na(deathYear)) |&gt; # filter for those without a deathYear\n  arrange(birthYear) |&gt; \n  slice(1) |&gt;\n  gt() |&gt; # create a display table\n  cols_label( # display column names\n    primaryName = \"Name\",\n    birthYear = \"Birth Year\"\n  )\n\n\n\n\n\n\n\n\nnconst\nName\nBirth Year\ndeathYear\nprimaryProfession\nknownForTitles\n\n\n\n\nnm5671597\nRobert De Visée\n1655\nNA\ncomposer,soundtrack\ntt2219674,tt1743724,tt0441074,tt14426058\n\n\n\n\n\n\n\nThe results of this first query says Robert De Visee but Robert was born in 1655, which does not make sense at all. A quick Google search says that the oldest person alive in 2024 is 116. Given that, let us filter for people born after 1914.\n\n\nDisplay Code\nNAME_BASICS |&gt; \n  filter(is.na(deathYear)) |&gt; # filter for those without a deathYear\n  filter(birthYear&gt;=1914) |&gt;\n  arrange(birthYear) |&gt; \n  slice(1)\n\n\n     nconst    primaryName birthYear deathYear primaryProfession\n1 nm0029349 Antonio Anelli      1914        NA             actor\n                           knownForTitles\n1 tt0072364,tt0068416,tt0065460,tt0068973\n\n\nLet’s perform a sanity check by confirming online. The internet says Antonio Anelli died on 12 May 1977.\n\n\nDisplay Code\nNAME_BASICS |&gt; \n  filter(is.na(deathYear)) |&gt; # filter for those without a deathYear\n  filter(birthYear&gt;=1916) |&gt;\n  arrange(birthYear) |&gt; \n  slice(1)\n\n\n     nconst primaryName birthYear deathYear                   primaryProfession\n1 nm0048527   Ivy Baker      1916        NA costume_department,costume_designer\n                           knownForTitles\n1 tt0041959,tt0054518,tt0066344,tt0042522\n\n\nIvy Baker born in 1916 and her bio on IMDb does not have a death year.\nTo be safe, let’s check for a year before 1916 and look at 1915.\n\n\nDisplay Code\nNAME_BASICS |&gt; \n  filter(is.na(deathYear)) |&gt; # filter for those without a deathYear\n  filter(birthYear&gt;=1915) |&gt;\n  arrange(birthYear) |&gt; \n  slice(1)\n\n\n     nconst    primaryName birthYear deathYear     primaryProfession\n1 nm0015296 Akhtar-Ul-Iman      1915        NA writer,actor,director\n                           knownForTitles\n1 tt0059893,tt0175450,tt0060689,tt0158587\n\n\nThe result says Akhtar-Ul-Iman but according to Wikipedia, he died on March 9, 1996.\n3. There is one TV Episode in this data set with a perfect 10/10 rating and 200,000 IMDb ratings.\n\n\nDisplay Code\nTITLE_RATINGS |&gt; \n  left_join(TITLE_EPISODES, by = \"tconst\") |&gt; # join using tconst\n  filter(averageRating == 10.0 & numVotes &gt;= 200000) |&gt; # filter by averageRating and numVotes\n  left_join(TITLE_BASICS, by = \"tconst\") |&gt; # join using tconst\n  left_join(TITLE_BASICS, join_by(\"parentTconst\" == \"tconst\")) |&gt;\n  select(primaryTitle.y, primaryTitle.x, averageRating, numVotes) |&gt; # select just the title, average rating, and number of votes\n  gt() |&gt; # create a display table\n  tab_header(\n    title = \"Perfect TV Episode\"\n  ) |&gt;\n  cols_label( # display column names\n    primaryTitle.y = \"TV Show\",\n    primaryTitle.x = \"Episode\",\n    averageRating = \"Average Rating\",\n    numVotes = \"Number of Votes\"\n  )\n\n\n\n\n\n\n\n\nPerfect TV Episode\n\n\nTV Show\nEpisode\nAverage Rating\nNumber of Votes\n\n\n\n\nBreaking Bad\nOzymandias\n10\n227589\n\n\n\n\n\n\n\n4. What four projects is the actor Mark Hammill most known for?\n\n\nDisplay Code\nlibrary(tidyr)\nNAME_BASICS |&gt; \n  filter(primaryName == \"Mark Hamill\") |&gt; \n  select(knownForTitles) |&gt; \n  separate_rows(knownForTitles, sep = \",\") |&gt;  # Split by comma to make each knownForTitle a row\n  left_join(TITLE_BASICS, by = c(\"knownForTitles\" = \"tconst\")) |&gt; # join to TITLE_BASICS on tconst\n  select(primaryTitle) |&gt; \n  head(4) |&gt;\n  gt() |&gt; # create a display table\n  tab_header(\n    title = \"Titles Mark Hammil is Known For\"\n  ) |&gt;\n  cols_label( # display column names\n    primaryTitle = \"Title\"\n  )\n\n\n\n\n\n\n\n\nTitles Mark Hammil is Known For\n\n\nTitle\n\n\n\n\nStar Wars: Episode IV - A New Hope\n\n\nStar Wars: Episode VIII - The Last Jedi\n\n\nStar Wars: Episode V - The Empire Strikes Back\n\n\nStar Wars: Episode VI - Return of the Jedi\n\n\n\n\n\n\n\n5. What TV series, with more than 12 episodes, has the highest average rating?\n\n\nDisplay Code\n# Find the highest-rated TV series with more than 12 episodes\n# tt15613780        9.7           318 Craft Games\n\nTITLE_BASICS |&gt;\n  filter(titleType == \"tvSeries\") |&gt;\n  right_join(TITLE_EPISODES, by = c(\"tconst\" = \"parentTconst\")) |&gt;\n  group_by(tconst) |&gt;\n  mutate(episode_count = n()) |&gt;\n  ungroup() |&gt;\n  filter(episode_count &gt; 12) |&gt;\n  left_join(TITLE_RATINGS, by = \"tconst\") |&gt;\n  arrange(desc(averageRating)) |&gt;\n  select(primaryTitle, averageRating, episode_count) |&gt;\n  head(1) |&gt;\n  gt() |&gt; # create a display table\n  tab_header(\n    title = \"Highest-Rated TV Series with More Than 12 Episodes\"\n  ) |&gt;\n  cols_label( # display column names\n    primaryTitle = \"TV Series\",\n    averageRating = \"Average Rating\",\n    episode_count = \"Number of Episodes\"\n  )\n\n\n\n\n\n\n\n\nHighest-Rated TV Series with More Than 12 Episodes\n\n\nTV Series\nAverage Rating\nNumber of Episodes\n\n\n\n\nCraft Games\n9.7\n318\n\n\n\n\n\n\n\n6. Is it true that episodes from later seasons of Happy Days have lower average ratings than the early seasons? The TV series Happy Days (1974-1984) gives us the common idiom “jump the shark”. The phrase comes from a controversial fifth season episode (aired in 1977) in which a lead character literally jumped over a shark on water skis. Idiomatically, it is used to refer to the moment when a once-great show becomes ridiculous and rapidly looses quality.\nFirst, I’m finding the tconst for Happy Days.\n\n\nDisplay Code\nTITLE_BASICS |&gt;\n  filter(originalTitle == \"Happy Days\") |&gt;\n  filter(titleType == \"tvSeries\") |&gt;\n  filter(startYear == \"1974\") |&gt;\n  select(tconst) # find the tconst for Happy Days\n\n\n     tconst\n1 tt0070992\n\n\nWe can see below that seasons 1 through 4 do well in terms of average rating. Aside from season 11, the seasons after season 5 are all in the bottom half of ratings. Meanwhile, season 3 has the highest rating of 7.7.\n\n\nDisplay Code\nTITLE_EPISODES |&gt; \n  filter(parentTconst == \"tt0070992\") |&gt; \n  left_join(TITLE_RATINGS, join_by(\"tconst\" )) |&gt; \n  group_by(seasonNumber) |&gt; \n  summarize(avg_rating = mean(averageRating, na.rm = TRUE)) |&gt; \n  mutate(seasonNumber = as.numeric(seasonNumber)) |&gt;\n  select(seasonNumber, avg_rating) |&gt;\n  arrange(desc(avg_rating)) |&gt; # arrange by average rating in descending order\n  gt() |&gt; # create a display table\n  tab_header(\n    title = \"Ratings for Happy Days by Season\"\n  ) |&gt;\n  cols_label( # display column names\n    seasonNumber = \"Season\",\n    avg_rating = \"Average Rating\"\n  )\n\n\n\n\n\n\n\n\nRatings for Happy Days by Season\n\n\nSeason\nAverage Rating\n\n\n\n\n3\n7.700000\n\n\n2\n7.691304\n\n\n1\n7.581250\n\n\n4\n7.428000\n\n\n11\n7.333333\n\n\n6\n7.018750\n\n\n5\n7.000000\n\n\n10\n6.700000\n\n\n9\n6.400000\n\n\n7\n6.333333\n\n\n8\n5.400000\n\n\n\n\n\n\n\nIn the plot below, we see that there is a indeed a dip in ratings in the later seasons of the show.\n\n\nDisplay Code\nseason_ratings &lt;- TITLE_EPISODES |&gt; \n  filter(parentTconst == \"tt0070992\") |&gt; \n  left_join(TITLE_RATINGS, join_by(\"tconst\" )) |&gt; \n  group_by(seasonNumber) |&gt; \n  summarize(avg_rating = mean(averageRating, na.rm = TRUE)) |&gt; \n  mutate(seasonNumber = as.numeric(seasonNumber)) |&gt;\n  select(seasonNumber, avg_rating) |&gt;\n  arrange(desc(seasonNumber)) # arrange by season in descending order\n\nlibrary(ggplot2)\n# Bar chart of average ratings by season \nggplot(season_ratings, aes(x = seasonNumber, y = avg_rating)) +\n  geom_bar(stat = \"identity\", fill = \"steelblue\") +\n  labs(title = \"Average Ratings of Happy Days by Season\",\n       x = \"Season Number\",\n       y = \"Average Rating\") +\n  ylim(0,10) +\n  scale_x_continuous(breaks = seq(1, 11, by = 1)) +\n  geom_text(aes(label=round(avg_rating, digits = 1)), vjust=0)"
  },
  {
    "objectID": "mp02.html#threshold-for-a-solid-title",
    "href": "mp02.html#threshold-for-a-solid-title",
    "title": "Proposing a Successful Film",
    "section": "Threshold for a Solid Title",
    "text": "Threshold for a Solid Title\nTo come up with a numerical threshold for a project to be a ‘success’ and determine a value such that movies above are all “solid” or better, I am going to use summary statistics. The 3rd Q is 0.6 and so I thinkk a score greater than 0.6 is “solid” and above the average movie.\n\n\nDisplay Code\nggplot(TITLE_RATINGS, aes(x=success_score)) + geom_histogram()\n\n\n\n\n\n\n\n\n\nDisplay Code\nsummary(TITLE_RATINGS$success_score)\n\n\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n 0.2046  0.4987  0.5517  0.5484  0.6000  0.9653"
  },
  {
    "objectID": "mp02.html#examining-success-by-genre-and-decade",
    "href": "mp02.html#examining-success-by-genre-and-decade",
    "title": "Proposing a Successful Film",
    "section": "Examining Success by Genre and Decade",
    "text": "Examining Success by Genre and Decade\nIn this section, we explore the interplay between film genres and their success across different decades, aiming to uncover trends that can inform a future project. By analyzing the performance of various genres over time, we can identify promising opportunities for an upcoming film.\n\n\nDisplay Code\n# highest average score\n# Biography, Adventure, Animation\nTITLE_BASICS |&gt;\n  left_join(TITLE_RATINGS, by = \"tconst\") |&gt;  # Corrected join syntax\n  separate_longer_delim(genres, \",\") |&gt; \n  group_by(genres) |&gt;  # Group by genres\n  summarise(avg_score = mean(success_score, na.rm = TRUE)) |&gt;\n  ungroup() |&gt;\n  arrange(desc(avg_score)) |&gt;\n  head(5)  |&gt;\n  gt() |&gt; # create a display table\n  tab_header(\n    title = \"Genres with Top 10 Average Success Scores\"\n  ) |&gt;\n  cols_label( # display column names\n    genres = \"Genre\",\n    avg_score = \"Average Success Score\"\n  )\n\n\n\n\n\n\n\n\nGenres with Top 10 Average Success Scores\n\n\nGenre\nAverage Success Score\n\n\n\n\nBiography\n0.5739485\n\n\nAdventure\n0.5732288\n\n\nAnimation\n0.5721809\n\n\nCrime\n0.5692845\n\n\nHistory\n0.5671059\n\n\n\n\n\n\n\nThe average success scores for the various genres seem fairly close to each other. Instead, we can count the number of success scores greater than the threshold of 0.6 for each genre.\n\n\nDisplay Code\n# Drama, Comedy, Action\nTITLE_BASICS |&gt;\n  left_join(TITLE_RATINGS, by = \"tconst\") |&gt;  # Corrected join syntax\n  filter(success_score &gt;= 0.6) |&gt; # greater than threshold\n  separate_longer_delim(genres, \",\") |&gt; \n  group_by(genres) |&gt;  # Group by genres\n  summarise(success_count = n()) |&gt;\n  ungroup() |&gt;\n  arrange(desc(success_count)) |&gt;\n  head(5) |&gt;\n  gt() |&gt; # create a display table\n  tab_header(\n    title = \"Genres with Top 10 Average Success Scores\"\n  ) |&gt;\n  cols_label( # display column names\n    genres = \"Genre\",\n    success_count = \"Number of Success Scores &gt; 0.60\"\n  )\n\n\n\n\n\n\n\n\nGenres with Top 10 Average Success Scores\n\n\nGenre\nNumber of Success Scores &gt; 0.60\n\n\n\n\nDrama\n52577\n\n\nComedy\n30306\n\n\nAction\n24394\n\n\nAdventure\n19408\n\n\nCrime\n19341\n\n\n\n\n\n\n\nWhat was the genre with the most “successes” in each decade? What genre consistently has the most “successes”?\n\n\nDisplay Code\n# Success by genre and decade\nsuccess_by_decade &lt;- TITLE_BASICS |&gt;\n  left_join(TITLE_RATINGS, by = \"tconst\") |&gt; \n  filter(success_score &gt;= 0.6) |&gt; \n  mutate(decade = floor(as.integer(startYear) / 10) * 10) |&gt;  # Create a decade column\n  separate_longer_delim(genres, \",\") |&gt; \n  group_by(decade, genres) |&gt; \n  summarise(success_count = n()) |&gt; \n  ungroup() |&gt;\n  arrange(decade, desc(success_count)) \n\n# Find the genre with the most successes in each decade\ntop_genre_per_decade &lt;- success_by_decade |&gt;\n  group_by(decade) |&gt; \n  slice_max(success_count, n = 1) # select top performing\n\n# Count how many times each genre is the highest in each decade\ntop_genre_per_decade |&gt;\n  group_by(genres) |&gt; \n  summarise(highest_count = n()) |&gt; \n  arrange(desc(highest_count)) |&gt;\n  gt() |&gt; # create a display table\n  tab_header(\n    title = \"Number of Times Genres Had the Most Successes of a Decade\"\n  ) |&gt;\n  cols_label( # display column names\n    genres = \"Genre\",\n    highest_count = \"Frequency\"\n  )\n\n\n\n\n\n\n\n\nNumber of Times Genres Had the Most Successes of a Decade\n\n\nGenre\nFrequency\n\n\n\n\nDrama\n12\n\n\nShort\n3\n\n\nComedy\n2\n\n\nDocumentary\n2\n\n\nSport\n1\n\n\n\n\n\n\n\nWhat genre used to reliably produced “successes” and has fallen out of favor?\n\n\nDisplay Code\nlibrary(ggrepel)\nlibrary(ggplot2)\n\ngenre_success &lt;- TITLE_BASICS |&gt;\n  inner_join(TITLE_RATINGS, by = \"tconst\") |&gt;\n  filter(success_score &gt; 0.6) |&gt;  # Set your success threshold\n  filter(!is.na(startYear) & !is.na(success_score)) |&gt;\n  separate_longer_delim(genres, \",\") |&gt; \n  group_by(genres, startYear) |&gt;\n  summarise(success_count = n())\n\ngenre_success |&gt;\n  ggplot(aes(x = startYear, y = success_count, color = genres)) +\n  geom_line(size = 0.5) +       # Use lines to connect points\n  geom_point(size = 1) +      # Add points for each data point\n  labs(\n    title = \"Count of Successful Movies by Genre Over Time\",\n    x = \"Year\",\n    y = \"Count of Successful Movies\",\n    color = \"Genre\"\n  ) +\n  theme_minimal() +\n  theme(legend.position = \"bottom\")\n\n\n\n\n\n\n\n\n\nWhat genre has produced the most “successes” since 2010? It seems that many films just get counted as Dramas with 32923 Dramas.\n\n\nDisplay Code\nTITLE_BASICS |&gt;\n  left_join(TITLE_RATINGS, by = \"tconst\") |&gt; \n  filter(success_score &gt;= 0.6, startYear &gt;= 2010) |&gt; # filter by 2010\n  separate_longer_delim(genres, \",\") |&gt; \n  group_by(genres) |&gt; \n  summarise(success_count = n()) |&gt; \n  ungroup() |&gt;\n  arrange(desc(success_count)) |&gt;\n  head(5) |&gt;\n  gt() |&gt; # create a display table\n  tab_header(\n    title = \"Success Count by Genre\"\n  ) |&gt;\n  cols_label( # display column names\n    genres = \"Genre\",\n    success_count = \"Success Count\"\n  )\n\n\n\n\n\n\n\n\nSuccess Count by Genre\n\n\nGenre\nSuccess Count\n\n\n\n\nDrama\n32923\n\n\nComedy\n16142\n\n\nAction\n15961\n\n\nCrime\n12626\n\n\nAdventure\n11665\n\n\n\n\n\n\n\nDisplay Code\nrecent_top_genres &lt;- TITLE_BASICS |&gt;\n  left_join(TITLE_RATINGS, by = \"tconst\") |&gt; \n  filter(success_score &gt;= 0.6, startYear &gt;= 2010) |&gt; \n  separate_longer_delim(genres, \",\") |&gt; \n  group_by(genres) |&gt; \n  summarise(success_count = n()) |&gt; \n  ungroup() |&gt;\n  arrange(desc(success_count)) |&gt;\n  head(5)\n\nrecent_top_genres |&gt;\n  ggplot(aes(x = genres, y = success_count, fill = genres)) +\n  geom_bar(stat=\"identity\") +\n  labs(\n    title = \"Count of Successful Movies by Genre Over Time\",\n    x = \"Genre\",\n    y = \"Count of Successful Movies\",\n    color = \"Genre\"\n  ) +\n  theme_minimal() +\n  theme(legend.position = \"bottom\")\n\n\n\n\n\n\n\n\n\nWithin the Drama genre, what were the most successful movies? It turns out the top movies we saw before all fall within the Drama genre as well.\n\n\nDisplay Code\nTITLE_RATINGS |&gt; \n  arrange(desc(success_score)) |&gt;  \n  left_join(TITLE_BASICS, join_by(\"tconst\" )) |&gt; \n  filter(titleType == 'movie') |&gt; \n  separate_longer_delim(genres, \",\") |&gt; \n  filter(genres == \"Drama\") |&gt;\n  select(primaryTitle, success_score, averageRating, numVotes) |&gt;\n  head(10) |&gt;\n  gt() |&gt; # create a display table\n  tab_header(\n    title = \"Most Successful Drama Movies\"\n  ) |&gt;\n  cols_label( # display column names\n    primaryTitle = \"Title\",\n    success_score = \"Success Score\",\n    averageRating = \"Average Rating\",\n    numVotes = \"Number of Votes\"\n  )\n\n\n\n\n\n\n\n\nMost Successful Drama Movies\n\n\nTitle\nSuccess Score\nAverage Rating\nNumber of Votes\n\n\n\n\nThe Shawshank Redemption\n0.9648769\n9.3\n2942823\n\n\nThe Dark Knight\n0.9495972\n9.0\n2922922\n\n\nThe Godfather\n0.9477853\n9.2\n2051186\n\n\nThe Lord of the Rings: The Return of the King\n0.9371353\n9.0\n2013824\n\n\nPulp Fiction\n0.9359758\n8.9\n2260017\n\n\nFight Club\n0.9326142\n8.8\n2374722\n\n\nThe Lord of the Rings: The Fellowship of the Ring\n0.9326021\n8.9\n2043202\n\n\nForrest Gump\n0.9315685\n8.8\n2301630\n\n\nSchindler's List\n0.9267397\n9.0\n1475891\n\n\nThe Godfather Part II\n0.9246497\n9.0\n1386499\n\n\n\n\n\n\n\nWhat about the second most successful genre, Comedy?\n\n\nDisplay Code\nTITLE_RATINGS |&gt; \n  arrange(desc(success_score)) |&gt;  \n  left_join(TITLE_BASICS, join_by(\"tconst\" )) |&gt; \n  filter(titleType == 'movie') |&gt; \n  separate_longer_delim(genres, \",\") |&gt; \n  filter(genres == \"Comedy\") |&gt;\n  select(primaryTitle, success_score, averageRating, numVotes) |&gt;\n  head(5) |&gt;\n  gt() |&gt; # create a display table\n  tab_header(\n    title = \"Most Successful Comedy Movies\"\n  ) |&gt;\n  cols_label( # display column names\n    primaryTitle = \"Title\",\n    success_score = \"Success Score\",\n    averageRating = \"Average Rating\",\n    numVotes = \"Number of Votes\"\n  )\n\n\n\n\n\n\n\n\nMost Successful Comedy Movies\n\n\nTitle\nSuccess Score\nAverage Rating\nNumber of Votes\n\n\n\n\nDjango Unchained\n0.9069468\n8.5\n1729019\n\n\nBack to the Future\n0.8982525\n8.5\n1333279\n\n\nThe Wolf of Wall Street\n0.8897217\n8.2\n1620302\n\n\nThe Intouchables\n0.8867587\n8.5\n945572\n\n\nLife Is Beautiful\n0.8842202\n8.6\n754383"
  },
  {
    "objectID": "mp02.html#successful-personnel-in-the-genre",
    "href": "mp02.html#successful-personnel-in-the-genre",
    "title": "Proposing a Successful Film",
    "section": "Successful Personnel in the Genre",
    "text": "Successful Personnel in the Genre\nAs I develop my team, I want to consider the benefits of pairing an older, established actor—someone with over 20 successful titles—to lend credibility and experience, alongside an up-and-coming actor who can bring fresh energy and appeal to a younger audience. This combination can create a dynamic synergy that enhances the project’s overall impact.\nWhen working with NAME_BASICS, I can only have alive personnel on my team. Here, I am creating a new data frame called ALIVE_NAME_BASICS.\n\n\nDisplay Code\nALIVE_NAME_BASICS &lt;- NAME_BASICS |&gt;\n  filter(birthYear &gt;= 1916, is.na(deathYear)) # Can only have alive personnel on my team\nsample_n(ALIVE_NAME_BASICS, 1000) |&gt;\n  DT::datatable()\n\n\n\n\n\n\nI will aso identify titles with a success score greater than 0.6 in SUCCESSFUL_TITLES.\n\n\nDisplay Code\n#Successful Movies Dataset\nSUCCESSFUL_TITLES &lt;- TITLE_BASICS |&gt;\n  left_join(TITLE_RATINGS, by = \"tconst\") |&gt;\n  filter(success_score &gt;= 0.6)\nsample_n(SUCCESSFUL_TITLES, 1000) |&gt;\n  DT::datatable()\n\n\n\n\n\n\n\nEstablished Drama Actors & Actresses\n\n\nDisplay Code\n# actor\nTITLE_PRINCIPALS |&gt;\n  filter(category == \"actor\") |&gt;\n  filter(tconst %in% SUCCESSFUL_TITLES$tconst) |&gt;\n  select(tconst, nconst) |&gt;\n  inner_join(ALIVE_NAME_BASICS, by = \"nconst\") |&gt;\n  inner_join(SUCCESSFUL_TITLES, by = \"tconst\") |&gt;\n  filter(titleType == \"movie\") |&gt;\n  separate_longer_delim(genres, \",\") |&gt; \n  filter(genres == \"Drama\") |&gt;\n  group_by(primaryName) |&gt;\n  summarise(\n    success_count = n(),\n    mean_success_score = mean(success_score, na.rm = TRUE)  # Ensure NA values are ignored\n  ) |&gt;\n  filter(success_count &gt;= 20) |&gt;\n  arrange(desc(mean_success_score), desc(success_count)) |&gt;\n  head(5)|&gt;\n  gt() |&gt; # create a display table\n  tab_header(\n    title = \"Top 5 Drama Actors\"\n  ) |&gt;\n  cols_label( # display column names\n    primaryName = \"Actor Name\",\n    success_count = \"Success Count\",\n    mean_success_score = \"Mean Success Score\"\n  )\n\n\n\n\n\n\n\n\nTop 5 Drama Actors\n\n\nActor Name\nSuccess Count\nMean Success Score\n\n\n\n\nBrad Pitt\n31\n0.7833171\n\n\nLeonardo DiCaprio\n28\n0.7801242\n\n\nChristian Bale\n38\n0.7641907\n\n\nRyan Gosling\n21\n0.7620046\n\n\nTom Hanks\n38\n0.7595574\n\n\n\n\n\n\n\n\n\nDisplay Code\n# actor\nTITLE_PRINCIPALS |&gt;\n  filter(category == \"actress\") |&gt;\n  filter(tconst %in% SUCCESSFUL_TITLES$tconst) |&gt;\n  select(tconst, nconst) |&gt;\n  inner_join(ALIVE_NAME_BASICS, by = \"nconst\") |&gt;\n  inner_join(SUCCESSFUL_TITLES, by = \"tconst\") |&gt;\n  filter(titleType == \"movie\") |&gt;\n  separate_longer_delim(genres, \",\") |&gt; \n  filter(genres == \"Drama\") |&gt;\n  group_by(primaryName) |&gt;\n  summarise(\n    success_count = n(),\n    mean_success_score = mean(success_score, na.rm = TRUE)  # Ensure NA values are ignored\n  ) |&gt;\n  filter(success_count &gt;= 20) |&gt;\n  arrange(desc(mean_success_score), desc(success_count)) |&gt;\n  head(5)|&gt;\n  gt() |&gt; # create a display table\n  tab_header(\n    title = \"Top 5 Drama Actresses\"\n  ) |&gt;\n  cols_label( # display column names\n    primaryName = \"Actor Name\",\n    success_count = \"Success Count\",\n    mean_success_score = \"Mean Success Score\"\n  )\n\n\n\n\n\n\n\n\nTop 5 Drama Actresses\n\n\nActor Name\nSuccess Count\nMean Success Score\n\n\n\n\nScarlett Johansson\n30\n0.7471914\n\n\nFrances McDormand\n24\n0.7253185\n\n\nEmily Blunt\n23\n0.7252131\n\n\nJessica Chastain\n24\n0.7219137\n\n\nNatalie Portman\n26\n0.7205248"
  },
  {
    "objectID": "mp02.html#up-and-coming-actors-actresses",
    "href": "mp02.html#up-and-coming-actors-actresses",
    "title": "Proposing a Successful Film",
    "section": "Up and Coming Actors & Actresses",
    "text": "Up and Coming Actors & Actresses\nTo find up and coming actors, I tried a couple of ways to define the criteria for “up and coming”. What if we consider mean success score? We could find top scoring actors but with low success counts.\n\n\nDisplay Code\n# actor\nTITLE_PRINCIPALS |&gt;\n  filter(category == \"actor\") |&gt;\n  filter(tconst %in% SUCCESSFUL_TITLES$tconst) |&gt;\n  select(tconst, nconst) |&gt;\n  inner_join(ALIVE_NAME_BASICS, by = \"nconst\") |&gt;\n  inner_join(SUCCESSFUL_TITLES, by = \"tconst\") |&gt;\n  filter(titleType == \"movie\") |&gt;\n  separate_longer_delim(genres, \",\") |&gt; \n  filter(genres == \"Drama\") |&gt;\n  group_by(primaryName) |&gt;\n  summarise(\n    success_count = n(),\n    mean_success_score = mean(success_score, na.rm = TRUE)  # Ensure NA values are ignored\n  ) |&gt;\n  arrange(desc(mean_success_score), desc(success_count)) |&gt;\n  head(5) |&gt;\n  gt() |&gt;\n  tab_header(\n    title = \"Top Scoring Actors with Low Success Counts\"\n  ) |&gt;\n  cols_label( # display column names\n    primaryName = \"Actor Name\",\n    success_count = \"Success Count\",\n    mean_success_score = \"Mean Success Score\"\n  )\n\n\n\n\n\n\n\n\nTop Scoring Actors with Low Success Counts\n\n\nActor Name\nSuccess Count\nMean Success Score\n\n\n\n\nMichael Conner Humphreys\n1\n0.9315685\n\n\nJohn Bach\n2\n0.9303864\n\n\nSala Baker\n4\n0.9303610\n\n\nJonathan Sagall\n1\n0.9267397\n\n\nShmuel Levy\n1\n0.9267397\n\n\n\n\n\n\n\nMichael Conner Humphreys has only been in 1 film where he played young Forrest Gump. This does not seem like the best way to define up and coming. I do want someone with a higher success count. What if I limit it to between 5 and 10 successful titles.\n\n\nDisplay Code\nTITLE_PRINCIPALS |&gt;\n  filter(category == \"actor\") |&gt;\n  filter(tconst %in% SUCCESSFUL_TITLES$tconst) |&gt;\n  select(tconst, nconst) |&gt;\n  inner_join(ALIVE_NAME_BASICS, by = \"nconst\") |&gt;\n  inner_join(SUCCESSFUL_TITLES, by = \"tconst\") |&gt;\n  separate_longer_delim(genres, \",\") |&gt; \n  filter(genres == \"Drama\") |&gt;\n  filter(titleType == \"movie\", startYear &gt;=2020) |&gt;\n  group_by(primaryName) |&gt;\n  summarise(\n    success_count = n(),\n    mean_success_score = mean(success_score, na.rm = TRUE)  # Ensure NA values are ignored\n  ) |&gt;\n  filter(success_count &gt;=5 & success_count &lt;=10) |&gt; # 5 to 10 successful titles\n  arrange(desc(mean_success_score), desc(success_count)) |&gt;\n  head(10) |&gt;\n  gt() |&gt;\n  tab_header(\n    title = \"Actors with High Success Scores and Between 5-10 Successful Titles Since 2020\"\n  ) |&gt;\n  cols_label( # display column names\n    primaryName = \"Actress Name\",\n    success_count = \"Success Count\",\n    mean_success_score = \"Mean Success Score\"\n  )\n\n\n\n\n\n\n\n\nActors with High Success Scores and Between 5-10 Successful Titles Since 2020\n\n\nActress Name\nSuccess Count\nMean Success Score\n\n\n\n\nTimothée Chalamet\n5\n0.8000488\n\n\nColin Farrell\n6\n0.7626842\n\n\nSahil Vaid\n5\n0.7508455\n\n\nJeffrey Wright\n5\n0.7449358\n\n\nMark Rylance\n5\n0.7401355\n\n\nAchyuth Kumar\n7\n0.7290892\n\n\nTom Hanks\n7\n0.7270197\n\n\nAjay Devgn\n9\n0.7232701\n\n\nRao Ramesh\n6\n0.7230589\n\n\nJohnny Flynn\n5\n0.7157819\n\n\n\n\n\n\n\nTom Hanks… I don’t think I could consider him an up and coming actor. Let us adjust again. It seems like the startYear lowers the success count. It only counts for recent movies and so established actors show up too because their earlier successes are not counted. Does up and coming mean young or just that their first movie was recent? I think older personell can be up and coming if they are just coming into the scene. Let’s try looking at the minimum start year of their first titles and actors with a number of successes.\n\n\nDisplay Code\nTITLE_PRINCIPALS |&gt;\n  filter(category == \"actor\") |&gt;\n  select(tconst, nconst) |&gt;\n  right_join(ALIVE_NAME_BASICS, by = \"nconst\") |&gt;\n  left_join(TITLE_BASICS, by = \"tconst\") |&gt;\n  left_join(TITLE_RATINGS, by = \"tconst\") |&gt;\n  separate_longer_delim(genres, \",\") |&gt; \n  filter(genres == \"Drama\", titleType == \"movie\") |&gt;\n  select(primaryName, primaryTitle, startYear, genres, success_score) |&gt;\n  filter(success_score &gt;= 0.6) |&gt;  # Filter by success score\n  group_by(primaryName) |&gt;  # group by actor\n  summarise(\n    debut_year = min(startYear, na.rm = TRUE),  # Compute first movie they did here\n    success_count = n(), # count succeses \n    mean_success_score = mean(success_score, na.rm = TRUE), # find mean success score\n    .groups = 'drop'\n  ) |&gt;\n  filter(debut_year &gt;= 2015, success_count &gt;= 5 & success_count &lt;= 10) |&gt;\n  arrange(desc(mean_success_score), desc(success_count)) |&gt;\n  head(5) |&gt;\n  gt() |&gt;\n  tab_header(\n    title = \"Up and Coming Actors\"\n  ) |&gt;\n  cols_label( # display column names\n    primaryName = \"Name\",\n    debut_year = \"Year of First Movie\",\n    success_count = \"Success Count\",\n    mean_success_score = \"Mean Success Score\"\n  )\n\n\n\n\n\n\n\n\nUp and Coming Actors\n\n\nName\nYear of First Movie\nSuccess Count\nMean Success Score\n\n\n\n\nAnthony Ramos\n2018\n5\n0.7734428\n\n\nNoah Jupe\n2017\n7\n0.7565397\n\n\nBarry Keoghan\n2017\n8\n0.7535545\n\n\nDave Bautista\n2015\n7\n0.7352465\n\n\nLeslie Odom Jr.\n2019\n5\n0.7348193\n\n\n\n\n\n\n\nSelecting Anthony Ramos, Noah Jupe, and Barry Keoghan from this list, I would consider them lesser known actors who were a part of successful films."
  },
  {
    "objectID": "mp02.html#combinations-of-personnel",
    "href": "mp02.html#combinations-of-personnel",
    "title": "Proposing a Successful Film",
    "section": "Combinations of Personnel",
    "text": "Combinations of Personnel\nActor/director pairs who have been successful together\n\n\nDisplay Code\n# Filter actors and directors first\nactors_df &lt;- TITLE_PRINCIPALS |&gt;\n  filter(category %in% c(\"actor\", \"actress\")) |&gt;\n  select(tconst, nconst)\n\ndirectors_df &lt;- TITLE_PRINCIPALS |&gt;\n  filter(category == \"director\") |&gt;\n  select(tconst, nconst)\n\n# Join actors and directors to create combinations\nactor_director_pairs &lt;- actors_df |&gt;\n  inner_join(directors_df, by = \"tconst\", suffix = c(\"_actor\", \"_director\"), relationship = \"many-to-many\")\n\nactor_director_names &lt;- actor_director_pairs |&gt;\n  inner_join(ALIVE_NAME_BASICS, by = c(\"nconst_actor\" = \"nconst\"), relationship = \"many-to-many\") |&gt; # join to names\n  rename(actor_name = primaryName) |&gt;\n  inner_join(ALIVE_NAME_BASICS, by = c(\"nconst_director\" = \"nconst\"), relationship = \"many-to-many\") |&gt; # join to names\n  rename(director_name = primaryName) |&gt;\n  inner_join(TITLE_BASICS, by = \"tconst\") |&gt; # join with titles\n  inner_join(TITLE_RATINGS, by = \"tconst\") # join with ratings\n\nactor_director_names |&gt; \n  group_by(actor_name, director_name) |&gt; # group by actor_name and director_name combinations\n  summarise(\n    success_count = n(), # count the number of times they've worked together\n    mean_success_score = mean(success_score, na.rm = TRUE)) |&gt; # find the mean success score\n  filter(mean_success_score &gt; 0.60) |&gt;\n  select(actor_name, director_name, success_count, mean_success_score) |&gt;\n  arrange(desc(success_count), desc(mean_success_score)) |&gt;\n  head(10)\n\n\n# A tibble: 10 × 4\n# Groups:   actor_name [10]\n   actor_name       director_name        success_count mean_success_score\n   &lt;chr&gt;            &lt;chr&gt;                        &lt;int&gt;              &lt;dbl&gt;\n 1 Trey Parker      Trey Parker                    888              0.669\n 2 Matt Stone       Trey Parker                    866              0.670\n 3 Masako Nozawa    Daisuke Nishio                 466              0.612\n 4 Hank Azaria      Mark Kirkland                  350              0.615\n 5 Dan Castellaneta Mark Kirkland                  346              0.614\n 6 Mona Marshall    Trey Parker                    338              0.674\n 7 Harry Shearer    Mark Kirkland                  336              0.615\n 8 Sam Marin        John Davis Infantino           301              0.685\n 9 Nancy Cartwright Mark Kirkland                  281              0.614\n10 William Salyers  John Davis Infantino           274              0.688\n\n\nI am getting mostly voice actors in the result above. My guess is this is due to episodes and tv series having a higher count. It may help to filter out the TV episodes. We can see how directors of TV series that work with the same actors multiple times may skew the success count.\n\n\nDisplay Code\nTITLE_BASICS |&gt;\n  group_by(titleType) |&gt;\n  summarize(count = n())\n\n\n# A tibble: 10 × 2\n   titleType     count\n   &lt;chr&gt;         &lt;int&gt;\n 1 movie        131662\n 2 short         16656\n 3 tvEpisode    155722\n 4 tvMiniSeries   5907\n 5 tvMovie       15007\n 6 tvSeries      29789\n 7 tvShort         410\n 8 tvSpecial      3045\n 9 video          9332\n10 videoGame      4668\n\n\nTop 10 Actor/Actress and Director Pairs in Drama Genre\n\n\nDisplay Code\nactor_director_names |&gt; \n  filter(titleType == \"movie\") |&gt; # filter for movies so results are not skewed by number of episodes\n  separate_longer_delim(genres, \",\") |&gt;\n  filter(genres == \"Drama\") |&gt; # filter by Drama\n  group_by(actor_name, director_name) |&gt; # group by actor_name and director_name combinations\n  summarise(\n    success_count = n(), # count the number of times they've worked together\n    mean_success_score = mean(success_score, na.rm = TRUE)) |&gt; # find the mean success score\n  filter(mean_success_score &gt; 0.60, success_count &gt; 5) |&gt;\n  arrange(desc(mean_success_score), desc(success_count)) |&gt;\n  head(10)\n\n\n# A tibble: 10 × 4\n# Groups:   actor_name [10]\n   actor_name          director_name     success_count mean_success_score\n   &lt;chr&gt;               &lt;chr&gt;                     &lt;int&gt;              &lt;dbl&gt;\n 1 Christian Bale      Christopher Nolan             7              0.913\n 2 Robert De Niro      Martin Scorsese               8              0.809\n 3 Ethan Hawke         Richard Linklater             7              0.766\n 4 Prabhas             S.S. Rajamouli                6              0.757\n 5 Frank Welker        Don Bluth                     6              0.757\n 6 Penélope Cruz       Pedro Almodóvar               6              0.739\n 7 Tony Leung Chiu-wai Kar-Wai Wong                  7              0.735\n 8 Woody Allen         Woody Allen                   7              0.729\n 9 Clint Eastwood      Clint Eastwood               18              0.728\n10 Megumi Hayashibara  Kazuya Tsurumaki             14              0.723\n\n\nWhat if we look at a specific director to see what actors and actresses they work well with. For example, if I wanted Steven Spielberg. Who has he worked well with in the past?\n\n\nDisplay Code\nactor_director_names |&gt; \n  filter(titleType == \"movie\") |&gt; # filter for movies so results are not skewed by number of episodes\n  filter(director_name == \"Steven Spielberg\") |&gt;\n  group_by(actor_name, director_name) |&gt; # group by actor_name and director_name combinations\n  summarise(\n    success_count = n(), # count the number of times they've worked together\n    mean_success_score = mean(success_score, na.rm = TRUE)) |&gt; # find the mean success score\n  select(actor_name, success_count, mean_success_score) |&gt;\n  arrange(desc(success_count), desc(mean_success_score)) |&gt;\n  head(5)\n\n\n# A tibble: 5 × 3\n# Groups:   actor_name [5]\n  actor_name    success_count mean_success_score\n  &lt;chr&gt;                 &lt;int&gt;              &lt;dbl&gt;\n1 Tom Hanks                 5              0.832\n2 Harrison Ford             4              0.830\n3 Mark Rylance              4              0.781\n4 Dan Aykroyd               4              0.669\n5 Simon Pegg                3              0.801\n\n\nNow let’s look at people the director has worked with at least twice.\n\n\nDisplay Code\nactor_director_names |&gt; \n  filter(titleType == \"movie\") |&gt; # filter for movies so results are not skewed by number of episodes\n  filter(director_name == \"Steven Spielberg\") |&gt;\n  group_by(actor_name, director_name) |&gt; # group by actor_name and director_name combinations\n  summarise(\n    success_count = n(), # count the number of times they've worked together\n    mean_success_score = mean(success_score, na.rm = TRUE)) |&gt; # find the mean success score\n  filter(success_count &gt;= 2) |&gt; # worked with multiple times (at least twice)\n  select(actor_name, success_count, mean_success_score) |&gt;\n  arrange(desc(mean_success_score), desc(success_count)) |&gt;\n  head(5) |&gt;\n  gt() |&gt;\n  tab_header(\n    title = \"Actors & Actresses Steven Spielberg Worked With\"\n  ) |&gt;\n  cols_label( # display column names\n    actor_name = \"Actor/Actress\",\n    success_count = \"Success Count\",\n    mean_success_score = \"Mean Success Score\"\n  )  \n\n\n\n\n\n\n\n\nActors & Actresses Steven Spielberg Worked With\n\n\nSuccess Count\nMean Success Score\n\n\n\n\nGiovanni Ribisi\n\n\n2\n0.9076895\n\n\nVic Tablian\n\n\n2\n0.8852299\n\n\nJohn Rhys-Davies\n\n\n2\n0.8761031\n\n\nCaroline Goodall\n\n\n2\n0.8435231\n\n\nTom Hanks\n\n\n5\n0.8319899"
  },
  {
    "objectID": "mp02.html#nostalgia-and-remakes",
    "href": "mp02.html#nostalgia-and-remakes",
    "title": "Proposing a Successful Film",
    "section": "Nostalgia and Remakes",
    "text": "Nostalgia and Remakes\nThe classic movie I propose to remake is The Princess Bride. Remaking The Princess Bride, a classic with an 8 IMDb rating, taps into a well-loved story while allowing us to introduce fresh talent, including original cast cameos, to engage both longtime fans and new audiences. The original has a large number of IMDb ratings, a high average rating, and has not been remade in the past 25 years. A Princess Bride Home Movie was created during COVID, a miniseries shot on phones from home, but a full film remake would be very successful. \n\n\nDisplay Code\nTITLE_BASICS |&gt;\n  filter(primaryTitle == \"The Princess Bride\")|&gt;\n  inner_join(TITLE_RATINGS, by = \"tconst\") |&gt;\n  select(primaryTitle, averageRating, numVotes, success_score) |&gt;\n  gt() |&gt;\n  tab_header(\n    title = \"The Princess Bride\"\n  ) |&gt;\n  cols_label( # display column names\n    primaryTitle = \"Title\",\n    averageRating = \"Average Rating\",\n    numVotes = \"Number of Votes\",\n    success_score = \"Success Score\"\n  )\n\n\n\n\n\n\n\n\nThe Princess Bride\n\n\nTitle\nAverage Rating\nNumber of Votes\nSuccess Score\n\n\n\n\nThe Princess Bride\n8\n456797\n0.8373338\n\n\n\n\n\n\n\nSuccessful Genres The Princess Bride is a film filled with Drama, Action, and Comedy, three of the top performing genres.\n\n\nDisplay Code\nrecent_top_genres &lt;- TITLE_BASICS |&gt;\n  left_join(TITLE_RATINGS, by = \"tconst\") |&gt; \n  filter(success_score &gt;= 0.6) |&gt; \n  separate_longer_delim(genres, \",\") |&gt; \n  filter(genres %in% c(\"Drama\", \"Comedy\", \"Action\")) |&gt;\n  group_by(genres, startYear) |&gt;  # Group by genres and startYear\n  summarise(success_count = n(), .groups = 'drop') |&gt; \n  ungroup() |&gt;\n  arrange(startYear, desc(success_count))\n\n\n\n\nDisplay Code\nggplot(recent_top_genres, aes(x = startYear, y = success_count, fill = genres)) +\n  geom_bar(stat = \"identity\") +\n  labs(\n    title = \"Growth of Successful Movies by Genre Over Time\",\n    x = \"Year\",\n    y = \"Count of Successful Movies\",\n    fill = \"Genre\"\n  ) +\n  theme_minimal() +\n  theme(legend.position = \"bottom\") +\n  facet_wrap(~ genres, scales = \"free_y\")  # Create separate plots for each genre\n\n\n\n\n\n\n\n\n\nKey Personnel Let’s confirm whether key actors, directors, or writers from the original are still alive.\n\n\nDisplay Code\nTITLE_PRINCIPALS |&gt;\n  filter(tconst == \"tt0093779\") |&gt;\n  inner_join(NAME_BASICS, by = \"nconst\") |&gt;\n  filter(category %in% c(\"actor\", \"actress\", \"director\", \"writer\")) |&gt;\n  select(primaryName, category, characters, deathYear) |&gt;\n  gt() |&gt; # create a display table\n  tab_header(\n    title = \"Key Personnel\"\n  ) |&gt;\n  cols_label( # display column names\n    primaryName = \"Name\",\n    category = \"Role\",\n    characters = \"Characters\",\n    deathYear = \"Death Year\"\n  )\n\n\n\n\n\n\n\n\nKey Personnel\n\n\nName\nRole\nCharacters\nDeath Year\n\n\n\n\nCary Elwes\nactor\n[\"Westley\"]\nNA\n\n\nMandy Patinkin\nactor\n[\"Inigo Montoya\"]\nNA\n\n\nRobin Wright\nactress\n[\"The Princess Bride\"]\nNA\n\n\nChristopher Guest\nactor\n[\"Count Rugen\"]\nNA\n\n\nWallace Shawn\nactor\n[\"Vizzini\"]\nNA\n\n\nAndré René Roussimoff\nactor\n[\"Fezzik\"]\n1993\n\n\nFred Savage\nactor\n[\"The Grandson\"]\nNA\n\n\nPeter Falk\nactor\n[\"The Grandfather\"]\n2011\n\n\nPeter Cook\nactor\n[\"The Impressive Clergyman\"]\n1995\n\n\nRob Reiner\ndirector\n\\N\nNA\n\n\nWilliam Goldman\nwriter\n\\N\n2018\n\n\n\n\n\n\n\nProven Director &lt;a\nRenowned for his ability to capture magic in storytelling, Steven Spielberg is ideal for reimagining this beloved classic. With Steven Spielberg, we can get a balance of heartfelt storytelling and commercial success, making this project a compelling remake. His success in genres such as Drama and Action fit well with The Princess Bride.\n\n\nDisplay Code\nNAME_BASICS |&gt;\n  filter(primaryName == 'Steven Spielberg') |&gt;\n  separate_longer_delim(knownForTitles, \",\") |&gt; \n  left_join(TITLE_BASICS, by = c(\"knownForTitles\" = \"tconst\")) |&gt; \n  left_join(TITLE_RATINGS, by = c(\"knownForTitles\" = \"tconst\")) |&gt;\n  select(primaryName, primaryTitle, success_score, averageRating, numVotes) |&gt;\n  arrange(desc(success_score)) |&gt;\n  gt() |&gt; # create a display table\n  tab_header(\n    title = \"Steven Spielberg    Project Scores\"\n  ) |&gt;\n  cols_label( # display column names\n    primaryName = \"Name\",\n    primaryTitle = \"Title\",\n    success_score = \"Success Score\",\n    averageRating = \"Average Rating\",\n    numVotes = \"Number of Votes\"\n  )\n\n\n\n\n\n\n\n\nSteven Spielberg Project Scores\n\n\nName\nTitle\nSuccess Score\nAverage Rating\nNumber of Votes\n\n\n\n\nSteven Spielberg\nSchindler's List\n0.9267397\n9.0\n1475891\n\n\nSteven Spielberg\nSaving Private Ryan\n0.9076895\n8.6\n1521594\n\n\nSteven Spielberg\nRaiders of the Lost Ark\n0.8852299\n8.4\n1049518\n\n\nSteven Spielberg\nE.T. the Extra-Terrestrial\n0.8313398\n7.9\n443655\n\n\n\n\n\n\n\nSteven Spielberg has consistently directed successful movies for over 5 decades.\n\n\nDisplay Code\nspielberg_success &lt;- TITLE_PRINCIPALS |&gt;\nfilter(nconst %in% NAME_BASICS$nconst[NAME_BASICS$primaryName == \"Steven Spielberg\"]) |&gt;\n  inner_join(TITLE_BASICS, by = \"tconst\") |&gt;\n  inner_join(TITLE_RATINGS, by = \"tconst\") |&gt;\n  select(primaryTitle, startYear, success_score) |&gt;\n  distinct() |&gt;  # Remove duplicates\n  mutate(successful = ifelse(success_score &gt;= 0.6, 1, 0)) |&gt;\n  group_by(startYear) |&gt;\n  summarise(success_count = sum(successful), .groups = 'drop') |&gt;\n  filter(success_count &gt; 0) |&gt;  # Only keep years with successful films\n  arrange(startYear)\n\n\n\n\nDisplay Code\n# Plotting\nggplot(spielberg_success, aes(x = startYear, y = success_count)) +\n  geom_line(color = \"blue\", size = .5) +\n  geom_point(color = \"blue\", size = 1) +\n  labs(title = \"Number of Successful Films Directed by Steven Spielberg Over Time\",\n       x = \"Year\",\n       y = \"Number of Successful Films\") +\n  scale_y_continuous(limits = c(0, NA)) +  # Set y-axis to start at 0\n  theme_minimal()\n\n\n\n\n\n\n\n\n\nCasting The original actress, Robin Wright, who played The Princess Bride has previously worked with Tom Hanks in the successful film Forrest Gump. However, it might be a good idea to cast some up and coming actors and actresses as leads to attract newer audience. We can keep Wallace Shawn as Vizzini for fans and a nod towards the original classic. By casting Mille Bobby Brown as The Princess Bride and Noah Jupe as Westley. Noah is known for his performances in A Quiet Place and Honey Boy, Jupe brings a fresh energy and charm suitable for the role of Westley. Timothée Chalamet could be cast as Inigo Montoya. His performances in Dune: Part Two and Part One make him an excellent choice for the iconic role of Inigo, seeking vengeance for his father."
  },
  {
    "objectID": "mp02.html#elevator-pitch",
    "href": "mp02.html#elevator-pitch",
    "title": "Proposing a Successful Film",
    "section": "Elevator Pitch",
    "text": "Elevator Pitch\nFrom the visionary mind of Steven Spielberg comes a timeless tale of adventure and romance, The Princess Bride. Featuring the talented Noah Jupe as Westley and the dynamic Millie Bobby Brown as Buttercup, this re-imagining will delight both old fans and new. With Timothée Chalamet as the iconic Inigo Montoya and Wallace Shawn reprising his role as Vizzini, alongside the incredible Julianne Moore, this film is a story of love, bravery, and the magic of storytelling—coming soon to theaters near you!\nThis remake promises to capture the heart of the original while inviting audiences into a fresh, enchanting cinematic experience."
  },
  {
    "objectID": "data-projects.html",
    "href": "data-projects.html",
    "title": "Data Projects",
    "section": "",
    "text": "Fiscal Characteristics of Major US Public Transit Systems\n\nAn investigation of ridership and the fiscal characteristics of US public transit authorities. In this project, I utilize dplyr operations (mutate, group_by, summarize, select, arrange, rename) in R to produce summary statistics.\nView Report"
  },
  {
    "objectID": "mp01.html",
    "href": "mp01.html",
    "title": "US Public Transit System Data Analysis",
    "section": "",
    "text": "When I was in Japan, I got to ride some of the most efficient transit systems in the world, characterized by its punctuality, its service, and the large numbers of passengers. Here in the United States, public transit is a whole different story. At the end of this analysis, I want to figure out what the most efficient transit system in the country is. How do I define efficiency? To me, efficiency can be broken down into ridership (trips, miles, the functionality) and financial efficiency (revenue, expenses). In this project, I will be investigating the usage and financial statistics of the US transit systems."
  },
  {
    "objectID": "mp01.html#introduction",
    "href": "mp01.html#introduction",
    "title": "US Public Transit System Data Analysis",
    "section": "",
    "text": "When I was in Japan, I got to ride some of the most efficient transit systems in the world, characterized by its punctuality, its service, and the large numbers of passengers. Here in the United States, public transit is a whole different story. At the end of this analysis, I want to figure out what the most efficient transit system in the country is. How do I define efficiency? To me, efficiency can be broken down into ridership (trips, miles, the functionality) and financial efficiency (revenue, expenses). In this project, I will be investigating the usage and financial statistics of the US transit systems."
  },
  {
    "objectID": "mp01.html#data-sets",
    "href": "mp01.html#data-sets",
    "title": "US Public Transit System Data Analysis",
    "section": "Data Sets",
    "text": "Data Sets\nThe National Transit Database (NTD) records the financial and operations of transit systems to keep track of the industry and provide public information and statistics. The data is collected by transit agencies and submitted to the Federal Administration (FTA) annually and reviewed by the FTA. The most recent and complete information available at the moment is for 2022. Let’s dive into it by exploring the following data sets from the FTA:\n\n2022 Fare Revenue\n2022 Expenses\nRidership\n\nI will be extracting data on fares, expenses,\n\nFare Revenue Data\n\n\n\n\n\n\n\n\nExpenses Data\n\n\n\n\n\n\n\n\nFinancials Data\nWe can inner join the Revenue and Expenses data into a more comprehensiive financials data set that we can do our analysis with.\nHere’s a sample of the Financials Data.\n\n\n\n\n\n\n\n\nTrips Data\nFrom the ridership data, I will be extracting information on public transportation trips taken by unlinked passengers.\n\n\n\n\n\n\n\n\nMiles Data\nAlso from the ridership data, I will be extracting information on the vehicle revenue miles.\n\n\n\n\n\n\n\n\nUsage Data\nWe can inner join the Trips and Miles data together using NTD ID into a data set on the usage.\nAttributes\nSome of the attribute namings are unclear so let’s use the FTA Glossary to interpret the data.\nRenaming\n\nrenaming UZA Name to metro_area\nreplacing the modes with their respective full names\nrenaming UPT to unlinked_passenger_trips\nrenaming VRM to vehicle_revenue_miles\n\nVRM (vehicle revenue miles): The miles that vehicles travel while in revenue service.\nUPT (unlinked passenger trips): The number of passengers who board public transportation vehicles. Passengers are counted each time they board vehicles no matter how many vehicles they use to travel from their origin to their destination.\nNow,, here’s a sample of the processed Usage Data.\n\n\n\n\n\n\n\n\nJoin Usage and Financial Data\nNext, we can join the Usage and Financial Data sets.\nIn order to do so, we need to get the Usage for 2022 in order to match the 2022 Financial data.\nSince we are joining on Mode, we need to convert the modes of the Financials data as well.\nAfter that, we can LEFT JOIN the two data sets.\nLet’s take a look at the Usage and Financials data."
  },
  {
    "objectID": "mp01.html#project-outcomes",
    "href": "mp01.html#project-outcomes",
    "title": "US Public Transit System Data Analysis",
    "section": "Project Outcomes",
    "text": "Project Outcomes\nI used summary statistics to explore the data sets processed above to extract insights that can shed light on efficiency of the US Public Transit Systems.\nLibraries: tidyverse, dplyr\nLet’s see what the data can tell us about public transit in the US looking at transit Usage and Financial data.\n\nVehicle Revenue Miles\nWhat transit agency had the most total VRM in this sample?\nMTA New York City Transit with 10832855350 total miles\n\nlibrary(dplyr)\nUSAGE |&gt; \n  group_by(Agency) |&gt;\n  summarise(total_VRM = sum(vehicle_revenue_miles)) |&gt;\n  arrange(desc(total_VRM)) |&gt;\n  slice(1)\n\n# A tibble: 1 × 2\n  Agency                      total_VRM\n  &lt;chr&gt;                           &lt;dbl&gt;\n1 MTA New York City Transit 10832855350\n\n\nWhat transit mode had the most total VRM in this sample?\nThe Bus at 49444494088 total miles\n\nUSAGE |&gt;\n  group_by(Mode) |&gt;\n  summarise(total_VRM = sum(vehicle_revenue_miles)) |&gt;\n  arrange(desc(total_VRM)) |&gt;\n  slice(1)\n\n# A tibble: 1 × 2\n  Mode    total_VRM\n  &lt;chr&gt;       &lt;dbl&gt;\n1 Bus   49444494088\n\n\nWhat mode of transport had the longest average trip in May 2024?\nThe Heavy Rail did with 2654864 average miles\n\nUSAGE |&gt; \n  filter(month == \"2024-05-01\") |&gt; \n  group_by(Mode) |&gt; \n  summarise(average_VRM = mean(vehicle_revenue_miles)) |&gt; \n  arrange(desc(average_VRM)) |&gt;\n  slice(1)\n\n# A tibble: 1 × 2\n  Mode       average_VRM\n  &lt;chr&gt;            &lt;dbl&gt;\n1 Heavy Rail    2654864.\n\n\n\n\nUnlinked Passenger Trips\nHow many trips were taken on the NYC Subway (Heavy Rail) in May 2024?\nA total of 237383777 trips were taken.\n\nTRIPS |&gt; \n  filter(Mode == \"HR\", month == \"2024-05-01\") |&gt; \n  summarise(total_trips = sum(UPT))\n\n# A tibble: 1 × 1\n  total_trips\n        &lt;dbl&gt;\n1   237383777\n\n\nHow much did NYC subway ridership fall between April 2019 and April 2020?\nRidership fell by 296864650 between April 2018 and April 2020.\n\napril_2020 &lt;- USAGE |&gt; \n  filter(Mode == \"Heavy Rail\") |&gt; \n  filter(month == \"2020-04-01\") |&gt; \n  summarise(total_riders = sum(unlinked_passenger_trips))\n\napril_2019 &lt;- USAGE |&gt; \n  filter(Mode == \"Heavy Rail\") |&gt; \n  filter(month == \"2019-04-01\") |&gt; \n  summarise(total_riders = sum(unlinked_passenger_trips))\n\ndifference = abs(april_2020 - april_2019)\nprint(difference)\n\n  total_riders\n1    296864650\n\n\nWhich transit system (agency and mode) had the most UPT in 2022?\nThe MTA New York City Transit Heavy Rail had the most UPT in 2022 at 1793073801.\n\nUSAGE_AND_FINANCIALS |&gt; select(Agency, Mode, UPT) |&gt; \n  arrange(desc(UPT))|&gt;\n  slice(1)\n\n# A tibble: 1 × 3\n  Agency                    Mode              UPT\n  &lt;chr&gt;                     &lt;chr&gt;           &lt;dbl&gt;\n1 MTA New York City Transit Heavy Rail 1793073801\n\n\n\n\nThree more interesting transit facts\nWhich month had the highest number of average trips between 2002 and 2024?\nOctober with an average of 768205 trips.\n\nUSAGE &lt;- USAGE |&gt; mutate(month_number = month(month))\nUSAGE |&gt; group_by(month_number) |&gt; summarise(avg_UPT = mean(unlinked_passenger_trips)) |&gt; arrange(desc(avg_UPT)) |&gt;\n  slice(1)\n\n# A tibble: 1 × 2\n  month_number avg_UPT\n         &lt;dbl&gt;   &lt;dbl&gt;\n1           10 768206.\n\nUSAGE &lt;- USAGE |&gt; select(-month_number)\n\nWhich metro area had the most unlinked passenger trips?\nThe New York, Jersey City, and Newark area has the greatest total UPT.\n\nUSAGE |&gt; group_by(metro_area) |&gt; \n  summarise(total_UPT = sum(unlinked_passenger_trips)) |&gt; \n  arrange(desc(total_UPT)) |&gt; \n  slice(1)\n\n# A tibble: 1 × 2\n  metro_area                              total_UPT\n  &lt;chr&gt;                                       &lt;dbl&gt;\n1 New York--Jersey City--Newark, NY--NJ 84020935224\n\n\nWhich metro area offers the most modes of transit?\nSan Francisco–Oakland, CA with 13 Modes\n\nUSAGE |&gt; group_by(metro_area) |&gt; \n  summarise(mode_count = n_distinct(Mode)) |&gt; \n  arrange(desc(mode_count)) |&gt; \n  slice(1)\n\n# A tibble: 1 × 2\n  metro_area                 mode_count\n  &lt;chr&gt;                           &lt;int&gt;\n1 San Francisco--Oakland, CA         13\n\n\n\ndistinct(USAGE |&gt; select(Mode, metro_area) |&gt; filter(metro_area == \"San Francisco--Oakland, CA\"))\n\n# A tibble: 13 × 2\n   Mode              metro_area                \n   &lt;chr&gt;             &lt;chr&gt;                     \n 1 Heavy Rail        San Francisco--Oakland, CA\n 2 Monorail          San Francisco--Oakland, CA\n 3 Demand Response   San Francisco--Oakland, CA\n 4 Bus               San Francisco--Oakland, CA\n 5 Commuter Bus      San Francisco--Oakland, CA\n 6 Bus Rapid Transit San Francisco--Oakland, CA\n 7 Cable Car         San Francisco--Oakland, CA\n 8 Light Rail        San Francisco--Oakland, CA\n 9 Streetcar         San Francisco--Oakland, CA\n10 Trolleybus        San Francisco--Oakland, CA\n11 Ferryboat         San Francisco--Oakland, CA\n12 Vanpool           San Francisco--Oakland, CA\n13 Commuter Rail     San Francisco--Oakland, CA"
  },
  {
    "objectID": "mp01.html#financial-efficiency",
    "href": "mp01.html#financial-efficiency",
    "title": "US Public Transit System Data Analysis",
    "section": "Financial Efficiency",
    "text": "Financial Efficiency\n\nFarebox Recovery Among Major Systems\nFarebox recovery is defined as the highest ratio of Total Fares to Expenses and can be used to measure efficiency.\nWhich transit system (agency and mode) had the highest farebox recovery?\nTransit Authority of Central Kentucky Vanpool has the highest farebox recovery at 2.38.\n\nUSAGE_AND_FINANCIALS |&gt; select(Agency, Mode, `Total Fares`, Expenses) |&gt; \n  mutate(farebox_recovery = `Total Fares`/Expenses) |&gt; \n  arrange(desc(farebox_recovery))|&gt;\n  slice(1)\n\n# A tibble: 1 × 5\n  Agency                           Mode  `Total Fares` Expenses farebox_recovery\n  &lt;chr&gt;                            &lt;chr&gt;         &lt;dbl&gt;    &lt;dbl&gt;            &lt;dbl&gt;\n1 Transit Authority of Central Ke… Vanp…         97300    40801             2.38\n\n\nWhich transit system (agency and mode) has the lowest expenses per UPT?\nSan Francisco Bay Area Rapid Transit District Heavy Rail has the lowest expenses per UPT at 0.396.\n\nUSAGE_AND_FINANCIALS |&gt; select(Agency, Mode, UPT, Expenses) |&gt; \n  mutate(Expenses_per_UPT = Expenses/UPT) |&gt; \n  arrange(Expenses_per_UPT)|&gt;\n  slice(1)\n\n# A tibble: 1 × 5\n  Agency                                  Mode     UPT Expenses Expenses_per_UPT\n  &lt;chr&gt;                                   &lt;chr&gt;  &lt;dbl&gt;    &lt;dbl&gt;            &lt;dbl&gt;\n1 San Francisco Bay Area Rapid Transit D… Heav… 4.53e7 17965407            0.396\n\n\nWhich transit system (agency and mode) has the highest total fares per UPT?\nThe highest total fares per UPT belongs to Altoona Metro Transit’s Demand Response at 656 per UPT.\n\nUSAGE_AND_FINANCIALS |&gt; select(Agency, Mode, `Total Fares`, UPT) |&gt; \n  mutate(Total_Fares_per_UPT = `Total Fares`/UPT) |&gt; \n  arrange(desc(Total_Fares_per_UPT))|&gt;\n  slice(1)\n\n# A tibble: 1 × 5\n  Agency                Mode            `Total Fares`   UPT Total_Fares_per_UPT\n  &lt;chr&gt;                 &lt;chr&gt;                   &lt;dbl&gt; &lt;dbl&gt;               &lt;dbl&gt;\n1 Altoona Metro Transit Demand Response         17058    26                656.\n\n\nWhich transit system (agency and mode) has the lowest expenses per VRM?\nSan Francisco Bay Area Rapid Transit District’s Heavy Rail at 0.217 per VRM.\n\nUSAGE_AND_FINANCIALS |&gt; select(Agency, Mode, Expenses, VRM) |&gt; \n  mutate(Expense_VRM = Expenses/VRM) |&gt; \n  arrange(Expense_VRM)|&gt;\n  slice(1)\n\n# A tibble: 1 × 5\n  Agency                                       Mode  Expenses    VRM Expense_VRM\n  &lt;chr&gt;                                        &lt;chr&gt;    &lt;dbl&gt;  &lt;dbl&gt;       &lt;dbl&gt;\n1 San Francisco Bay Area Rapid Transit Distri… Heav… 17965407 8.27e7       0.217\n\n\nWhich transit system (agency and mode) has the highest total fares per VRM?\nChicago Water Taxi (Wendella)’s Ferryboat at 237 total fares per VRM\n\nUSAGE_AND_FINANCIALS |&gt; select(Agency, Mode, `Total Fares`, VRM) |&gt; \n  mutate(Fares_VRM = `Total Fares`/VRM) |&gt;\n  arrange(desc(Fares_VRM)) |&gt;\n  slice(1)\n\n# A tibble: 1 × 5\n  Agency                        Mode      `Total Fares`   VRM Fares_VRM\n  &lt;chr&gt;                         &lt;chr&gt;             &lt;dbl&gt; &lt;dbl&gt;     &lt;dbl&gt;\n1 Chicago Water Taxi (Wendella) Ferryboat        142473   600      237."
  },
  {
    "objectID": "mp01.html#conclusion",
    "href": "mp01.html#conclusion",
    "title": "US Public Transit System Data Analysis",
    "section": "Conclusion",
    "text": "Conclusion\nIn terms of ridership, the MTA New York City Transit takes the win in with the most Vehicle Revenue Miles and the most Unlinked Passenger Trips in 2022. Ridership in the NYC, NJ, Newark area overall is the highest and the transit systems in the area are some of the most utilized public transit systems in the US. Financially, San Francisco’s BART Heavy Rail/Subway comes out on top with both the lowest expense per VRM and lowest expense per UPT. Additionally, San Francisco/Oakland, CA also offers the most modes of transportation. When it comes to usage, the MTA is the transit system that shines, covering the most revenue miles with its vehicles and servicing the most passenger trips. When finances are added to the picture, the BART seems to be the most cost effective transit system."
  }
]