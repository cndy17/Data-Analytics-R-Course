---
title: "Proposing a Successful Film"
format: html
---


## Data
This project uses data made available by [Internet Movie Database (IMDb)](https://datasets.imdbws.com/). 
While I did intially use the full data set in my analysis, I switched over to using a sub-sampled pre-processed data because my computer was struggling to handle the full data. 
``` {r}
#| label: 'get_imdb_file'
#| message: false 
#| warning: false
#| cache: true
library(tidyverse)
library(dplyr)
library(tidyr)
library(ggplot2)
library(gt)

get_imdb_file <- function(fname){
  fname_ext <- paste0(fname, ".csv.zip")
  as.data.frame(readr::read_csv(fname_ext, lazy=FALSE))
}

NAME_BASICS <- get_imdb_file("name_basics_small")
TITLE_BASICS     <- get_imdb_file("title_basics_small")
TITLE_EPISODES <- get_imdb_file("title_episodes_small")
TITLE_RATINGS <- get_imdb_file("title_ratings_small")
TITLE_CREW <- get_imdb_file("title_crew_small")
TITLE_PRINCIPALS <- get_imdb_file("title_principals_small")
```

Below, I am converting the birth year and death year to numeric data types.
```{r echo=TRUE, message=FALSE, warning=FALSE}
#| message: false 
#| warning: false
#| cache: true
NAME_BASICS <- NAME_BASICS |>
  mutate(birthYear = as.numeric(birthYear), # numeric birth years
         deathYear = as.numeric(deathYear))
```

With that, the data I am using has been narrowed down significantly to a smaller and manageable sub sample.

### Name Basics
```{r echo=TRUE, message=FALSE, warning=FALSE}
#| code-fold: true
#| code-summary: "Display Code"
library(DT)
library(dplyr)

sample_n(NAME_BASICS, 1000) |>
  DT::datatable()
```

### Title Basics
```{r echo=TRUE, message=FALSE, warning=FALSE}
#| code-fold: true
#| code-summary: "Display Code"
sample_n(TITLE_BASICS, 1000) |>
  DT::datatable()
```

### Title Crew
```{r echo=TRUE, message=FALSE, warning=FALSE}
#| code-fold: true
#| code-summary: "Display Code"
sample_n(TITLE_CREW, 1000) |>
  DT::datatable()
```

### Title Episodes
```{r echo=TRUE, message=FALSE, warning=FALSE}
#| code-fold: true
#| code-summary: "Display Code"
sample_n(TITLE_EPISODES, 1000) |>
  DT::datatable()
```

### Title Ratings
```{r echo=TRUE, message=FALSE, warning=FALSE}
#| code-fold: true
#| code-summary: "Display Code"
sample_n(TITLE_RATINGS, 1000) |>
  DT::datatable()
```

### Title Principals
```{r echo=TRUE, message=FALSE, warning=FALSE}
#| code-fold: true
#| code-summary: "Display Code"
sample_n(TITLE_PRINCIPALS, 1000) |>
  DT::datatable()
```

## Preliminary Exploration
**1. How many movies are in our data set? How many TV series? How many TV episodes?**
```{r echo=TRUE, message=FALSE, warning=FALSE}
#| code-fold: true
#| code-summary: "Display Code"
library(gt)
TITLE_BASICS |>
  group_by(titleType) |>
  filter(titleType %in% c("movie", "tvSeries", "tvEpisode" )) |>
  summarise(count = n()) |>
  gt() |> # create a display table
  tab_header(
    title = "Number of Title Types"
  ) |>
  cols_label( # display column names
    titleType = "Type",
    count = "Count"
  )
```

**2. Who is the oldest living person in our data set?**
```{r echo=TRUE, message=FALSE, warning=FALSE}
#| code-fold: true
#| code-summary: "Display Code"
NAME_BASICS |> 
  filter(is.na(deathYear)) |> # filter for those without a deathYear
  arrange(birthYear) |> 
  slice(1) |>
  gt() |> # create a display table
  cols_label( # display column names
    primaryName = "Name",
    birthYear = "Birth Year"
  )
```
The results of this first query says Robert De Visee but Robert was born in 1655, which does not make sense at all. A quick Google search says that the oldest person alive in 2024 is 116. Given that, let us filter for people born after 1914.
```{r echo=TRUE, message=FALSE, warning=FALSE}
#| code-fold: true
#| code-summary: "Display Code"
NAME_BASICS |> 
  filter(is.na(deathYear)) |> # filter for those without a deathYear
  filter(birthYear>=1914) |>
  arrange(birthYear) |> 
  slice(1)
```
Let's perform a sanity check by confirming online. The internet says Antonio Anelli died on 12 May 1977.

```{r echo=TRUE, message=FALSE, warning=FALSE}
#| code-fold: true
#| code-summary: "Display Code"
NAME_BASICS |> 
  filter(is.na(deathYear)) |> # filter for those without a deathYear
  filter(birthYear>=1916) |>
  arrange(birthYear) |> 
  slice(1)
```
Ivy Baker born in 1916 and her bio on IMDb does not have a death year.

To be safe, let's check for a year before 1916 and look at 1915.
```{r echo=TRUE, message=FALSE, warning=FALSE}
#| code-fold: true
#| code-summary: "Display Code"
NAME_BASICS |> 
  filter(is.na(deathYear)) |> # filter for those without a deathYear
  filter(birthYear>=1915) |>
  arrange(birthYear) |> 
  slice(1)
```
The result says Akhtar-Ul-Iman but according to Wikipedia, he died on March 9, 1996.

**3. There is one TV Episode in this data set with a perfect 10/10 rating and 200,000 IMDb ratings.** 
```{r echo=TRUE, message=FALSE, warning=FALSE}
#| code-fold: true
#| code-summary: "Display Code"
TITLE_RATINGS |> 
  left_join(TITLE_EPISODES, by = "tconst") |> # join using tconst
  filter(averageRating == 10.0 & numVotes >= 200000) |> # filter by averageRating and numVotes
  left_join(TITLE_BASICS, by = "tconst") |> # join using tconst
  left_join(TITLE_BASICS, join_by("parentTconst" == "tconst")) |>
  select(primaryTitle.y, primaryTitle.x, averageRating, numVotes) |> # select just the title, average rating, and number of votes
  gt() |> # create a display table
  tab_header(
    title = "Perfect TV Episode"
  ) |>
  cols_label( # display column names
    primaryTitle.y = "TV Show",
    primaryTitle.x = "Episode",
    averageRating = "Average Rating",
    numVotes = "Number of Votes"
  )
```

**4. What four projects is the actor Mark Hammill most known for?**
```{r echo=TRUE, message=FALSE, warning=FALSE}
#| code-fold: true
#| code-summary: "Display Code"
library(tidyr)
NAME_BASICS |> 
  filter(primaryName == "Mark Hamill") |> 
  select(knownForTitles) |> 
  separate_rows(knownForTitles, sep = ",") |>  # Split by comma to make each knownForTitle a row
  left_join(TITLE_BASICS, by = c("knownForTitles" = "tconst")) |> # join to TITLE_BASICS on tconst
  select(primaryTitle) |> 
  head(4) |>
  gt() |> # create a display table
  tab_header(
    title = "Titles Mark Hammil is Known For"
  ) |>
  cols_label( # display column names
    primaryTitle = "Title"
  )
```

**5. What TV series, with more than 12 episodes, has the highest average rating?**
```{r echo=TRUE, message=FALSE, warning=FALSE}
#| code-fold: true
#| code-summary: "Display Code"
# Find the highest-rated TV series with more than 12 episodes
# tt15613780        9.7           318 Craft Games

TITLE_BASICS |>
  filter(titleType == "tvSeries") |>
  right_join(TITLE_EPISODES, by = c("tconst" = "parentTconst")) |>
  group_by(tconst) |>
  mutate(episode_count = n()) |>
  ungroup() |>
  filter(episode_count > 12) |>
  left_join(TITLE_RATINGS, by = "tconst") |>
  arrange(desc(averageRating)) |>
  select(primaryTitle, averageRating, episode_count) |>
  head(1) |>
  gt() |> # create a display table
  tab_header(
    title = "Highest-Rated TV Series with More Than 12 Episodes"
  ) |>
  cols_label( # display column names
    primaryTitle = "TV Series",
    averageRating = "Average Rating",
    episode_count = "Number of Episodes"
  )
```

**6. Is it true that episodes from later seasons of Happy Days have lower average ratings than the early seasons?**
The TV series Happy Days (1974-1984) gives us the common idiom “jump the shark”. The phrase comes from a controversial fifth season episode (aired in 1977) in which a lead character literally jumped over a shark on water skis. Idiomatically, it is used to refer to the moment when a once-great show becomes ridiculous and rapidly looses quality.

First, I'm finding the tconst for Happy Days.
```{r echo=TRUE, message=FALSE, warning=FALSE}
#| code-fold: true
#| code-summary: "Display Code"
TITLE_BASICS |>
  filter(originalTitle == "Happy Days") |>
  filter(titleType == "tvSeries") |>
  filter(startYear == "1974") |>
  select(tconst) # find the tconst for Happy Days
```
We can see below that seasons 1 through 4 do well in terms of average rating. Aside from season 11, the seasons after season 5 are all in the bottom half of ratings. Meanwhile, season 3 has the highest rating of 7.7. 
```{r echo=TRUE, message=FALSE, warning=FALSE}
#| code-fold: true
#| code-summary: "Display Code"
TITLE_EPISODES |> 
  filter(parentTconst == "tt0070992") |> 
  left_join(TITLE_RATINGS, join_by("tconst" )) |> 
  group_by(seasonNumber) |> 
  summarize(avg_rating = mean(averageRating, na.rm = TRUE)) |> 
  mutate(seasonNumber = as.numeric(seasonNumber)) |>
  select(seasonNumber, avg_rating) |>
  arrange(desc(avg_rating)) |> # arrange by average rating in descending order
  gt() |> # create a display table
  tab_header(
    title = "Ratings for Happy Days by Season"
  ) |>
  cols_label( # display column names
    seasonNumber = "Season",
    avg_rating = "Average Rating"
  )
```

In the plot below, we see that there is a indeed a dip in ratings in the later seasons of the show. 
```{r echo=TRUE, message=FALSE, warning=FALSE}
#| code-fold: true
#| code-summary: "Display Code"
season_ratings <- TITLE_EPISODES |> 
  filter(parentTconst == "tt0070992") |> 
  left_join(TITLE_RATINGS, join_by("tconst" )) |> 
  group_by(seasonNumber) |> 
  summarize(avg_rating = mean(averageRating, na.rm = TRUE)) |> 
  mutate(seasonNumber = as.numeric(seasonNumber)) |>
  select(seasonNumber, avg_rating) |>
  arrange(desc(seasonNumber)) # arrange by season in descending order

library(ggplot2)
# Bar chart of average ratings by season 
ggplot(season_ratings, aes(x = seasonNumber, y = avg_rating)) +
  geom_bar(stat = "identity", fill = "steelblue") +
  labs(title = "Average Ratings of Happy Days by Season",
       x = "Season Number",
       y = "Average Rating") +
  ylim(0,10) +
  scale_x_continuous(breaks = seq(1, 11, by = 1)) +
  geom_text(aes(label=round(avg_rating, digits = 1)), vjust=0)
```

# Quantifying Success
Next, I will be designing a ‘success’ measure for IMDb entries, reflecting both quality and broad popular awareness. I will be adding this measure to the TITLE_RATINGS table.

Initially, I did a composite score of averageRating and numVotes to consider both quality and popularity. I then divided this by the max possible score in the data population.  
(averageRating x numVotes ) / (max(averageRating) x max(numVotes))
```{r echo=TRUE, message=FALSE, warning=FALSE}
#| code-fold: true
#| code-summary: "Display Code"

TITLE_RATINGS$score <- (TITLE_RATINGS$averageRating * TITLE_RATINGS$numVotes) /
  (max(TITLE_RATINGS$averageRating) * max(TITLE_RATINGS$numVotes))
# plot to see spread/distribution
ggplot(TITLE_RATINGS, aes(x=score)) + geom_histogram()
```

I don't want the number of votes to throw off the score. Let's use log on numVotes and maybe I want to give more weight to the rating than the number of votes. 
(0.6 x averageRating + 0.4 x log(numVotes)) / (0.6 x max(averageRating) + 0.4 x log(max(numVotes)))
```{r echo=TRUE, message=FALSE, warning=FALSE}
#| code-fold: true
#| code-summary: "Display Code"
#| cache: true

TITLE_RATINGS$success_score <- (.6*TITLE_RATINGS$averageRating + .4*log(TITLE_RATINGS$numVotes)) /
  (.6*max(TITLE_RATINGS$averageRating) + .4*log(max(TITLE_RATINGS$numVotes)))

ggplot(TITLE_RATINGS, aes(x=success_score)) + geom_histogram() +
  labs(title = "Success Score Distribution",
       x = "Success Score",
       y = "Frequency")

```

Now that there is a success score, let's validate the metric with a number of tests and see how it holds up. First, I'm confirming that the the top 5-10 movies based on my metric were indeed box office successes. 
```{r echo=TRUE, message=FALSE, warning=FALSE}
#| code-fold: true
#| code-summary: "Display Code"
TITLE_RATINGS |> 
  arrange(desc(success_score)) |>  
  left_join(TITLE_BASICS, join_by("tconst" )) |> 
  filter(titleType == 'movie') |> 
  select(primaryTitle, success_score, averageRating, numVotes) |>
  head(10) |>
  gt() |> # create a display table
  tab_header(
    title = "Most Successful Movies"
  ) |>
  cols_label( # display column names
    primaryTitle = "Title",
    success_score = "Success Score",
    averageRating = "Average Rating",
    numVotes = "Number of Votes"
  )

```
  
Next, let's use the success metric to find movies with large numbers of IMDb votes that score poorly  and confirm that they are indeed of low quality.
```{r echo=TRUE, message=FALSE, warning=FALSE}
#| code-fold: true
#| code-summary: "Display Code"
summary(TITLE_RATINGS$numVotes)

TITLE_RATINGS |> 
  arrange(success_score) |> # arrage ascending
  left_join(TITLE_BASICS, join_by("tconst" )) |> 
  filter(titleType == 'movie') |>
  filter(numVotes >= 4022) |> # Mean numVotes is 4022
  select(primaryTitle, success_score, averageRating, numVotes) |>
  head(5) |> # select bottom 5
  gt() |> # create a display table
  tab_header(
    title = "Least Successful Movies"
  ) |>
  cols_label( # display column names
    primaryTitle = "Title",
    success_score = "Success Score",
    averageRating = "Average Rating",
    numVotes = "Number of Votes"
  )
```

Now, to check in with the people, I will choose prestige actors or directors and confirm that they have many projects with high scores on my success metric.

**Hayao Miyazaki**
```{r echo=TRUE, message=FALSE, warning=FALSE}
#| code-fold: true
#| code-summary: "Display Code"
NAME_BASICS |>
  filter(primaryName == 'Rob Reiner') |>
  separate_longer_delim(knownForTitles, ",") |> 
  left_join(TITLE_BASICS, by = c("knownForTitles" = "tconst")) |> 
  left_join(TITLE_RATINGS, by = c("knownForTitles" = "tconst")) |>
  select(primaryName, primaryTitle, success_score, averageRating, numVotes) |>
  arrange(desc(success_score)) |>
  gt() |> # create a display table
  tab_header(
    title = "Rob Reiner Project Scores"
  ) |>
  cols_label( # display column names
    primaryName = "Name",
    primaryTitle = "Title",
    success_score = "Success Score",
    averageRating = "Average Rating",
    numVotes = "Number of Votes"
  )
```  
**Christopher Nolan**
```{r echo=TRUE, message=FALSE, warning=FALSE}
#| code-fold: true
#| code-summary: "Display Code"
NAME_BASICS |>
  filter(primaryName == 'Christopher Nolan') |>
  separate_longer_delim(knownForTitles, ",") |> 
  left_join(TITLE_BASICS, by = c("knownForTitles" = "tconst")) |> 
  left_join(TITLE_RATINGS, by = c("knownForTitles" = "tconst")) |>
  filter(!is.na(primaryTitle)) |>
  select(primaryName, primaryTitle, success_score, averageRating, numVotes) |>
  arrange(desc(success_score)) |>
  gt() |> # create a display table
  tab_header(
    title = "Christopher Nolan Project Scores"
  ) |>
  cols_label( # display column names
    primaryName = "Name",
    primaryTitle = "Title",
    success_score = "Success Score",
    averageRating = "Average Rating",
    numVotes = "Number of Votes"
  )
``` 

**Steven Spielberg**
```{r echo=TRUE, message=FALSE, warning=FALSE}
#| code-fold: true
#| code-summary: "Display Code"
NAME_BASICS |>
  filter(primaryName == 'Steven Spielberg') |>
  separate_longer_delim(knownForTitles, ",") |> 
  left_join(TITLE_BASICS, by = c("knownForTitles" = "tconst")) |> 
  left_join(TITLE_RATINGS, by = c("knownForTitles" = "tconst")) |>
  select(primaryName, primaryTitle, success_score, averageRating, numVotes) |>
  arrange(desc(success_score)) |>
  gt() |> # create a display table
  tab_header(
    title = "Steven Spielberg Project Scores"
  ) |>
  cols_label( # display column names
    primaryName = "Name",
    primaryTitle = "Title",
    success_score = "Success Score",
    averageRating = "Average Rating",
    numVotes = "Number of Votes"
  )
``` 
**Greta Gerwig**
```{r echo=TRUE, message=FALSE, warning=FALSE}
#| code-fold: true
#| code-summary: "Display Code"
NAME_BASICS |>
  filter(primaryName == 'Greta Gerwig') |>
  separate_longer_delim(knownForTitles, ",") |> 
  left_join(TITLE_BASICS, by = c("knownForTitles" = "tconst")) |> 
  left_join(TITLE_RATINGS, by = c("knownForTitles" = "tconst")) |>
  select(primaryName, primaryTitle, success_score, averageRating, numVotes) |>
  arrange(desc(success_score)) |>
  gt() |> # create a display table
  tab_header(
    title = "Greta Gerwig Project Scores"
  ) |>
  cols_label( # display column names
    primaryName = "Name",
    primaryTitle = "Title",
    success_score = "Success Score",
    averageRating = "Average Rating",
    numVotes = "Number of Votes"
  )
``` 
**Meryl Streep**
```{r echo=TRUE, message=FALSE, warning=FALSE}
#| code-fold: true
#| code-summary: "Display Code"
NAME_BASICS |>
  filter(primaryName == 'Meryl Streep') |>
  separate_longer_delim(knownForTitles, ",") |> 
  left_join(TITLE_BASICS, by = c("knownForTitles" = "tconst")) |> 
  left_join(TITLE_RATINGS, by = c("knownForTitles" = "tconst")) |>
  select(primaryName, primaryTitle, success_score, averageRating, numVotes) |>
  arrange(desc(success_score)) |>
  gt() |> # create a display table
  tab_header(
    title = "Meryl Streep Project Scores"
  ) |>
  cols_label( # display column names
    primaryName = "Name",
    primaryTitle = "Title",
    success_score = "Success Score",
    averageRating = "Average Rating",
    numVotes = "Number of Votes"
  )
``` 
Here, we can notice how numVotes is also taken into consideration, pushing the Devil Wears Prada to the top even though it does not have the highest Average Rating. 

As another ‘spot check’ validation, let's check the scores of the highest grossing titles. 
The highest grossing title is Avatar.
```{r echo=TRUE, message=FALSE, warning=FALSE}
#| code-fold: true
#| code-summary: "Display Code"
# highest grossing title is Avatar - score of .75
TITLE_BASICS |>
  filter(originalTitle == 'Avatar') |>
  filter(titleType == 'movie') |>
  left_join(TITLE_RATINGS, join_by("tconst")) |>
  select(primaryTitle, success_score, averageRating, numVotes) |>
  gt() |> # create a display table
  tab_header(
    title = "Avatar"
  ) |>
  cols_label( # display column names
    primaryTitle = "Title",
    success_score = "Success Score",
    averageRating = "Average Rating",
    numVotes = "Number of Votes"
  )
```

The second highest grossing is Avengers: Endgame. 
```{r echo=TRUE, message=FALSE, warning=FALSE}
#| code-fold: true
#| code-summary: "Display Code"
# second is Avengers: Endgame - score of .79
TITLE_BASICS |>
  filter(originalTitle == 'Avengers: Endgame') |>
  filter(titleType == 'movie') |>
  left_join(TITLE_RATINGS, join_by("tconst")) |>
  select(primaryTitle, success_score, averageRating, numVotes) |>
  gt() |> # create a display table
  tab_header(
    title = "Avengers: Endgame"
  ) |>
  cols_label( # display column names
    primaryTitle = "Title",
    success_score = "Success Score",
    averageRating = "Average Rating",
    numVotes = "Number of Votes"
  )
```

## Threshold for a Solid Title
To come up with a numerical threshold for a project to be a ‘success’ and determine a value such that movies above are all “solid” or better, I am going to use summary statistics. The 3rd Q is 0.6 and so I thinkk a score greater than 0.6 is "solid" and above the average movie. 
```{r echo=TRUE, message=FALSE, warning=FALSE}
#| code-fold: true
#| code-summary: "Display Code"
ggplot(TITLE_RATINGS, aes(x=success_score)) + geom_histogram()
summary(TITLE_RATINGS$success_score)
```

## Examining Success by Genre and Decade
In this section, we explore the interplay between film genres and their success across different decades, aiming to uncover trends that can inform a future project. By analyzing the performance of various genres over time, we can identify promising opportunities for an upcoming film. 

```{r echo=TRUE, message=FALSE, warning=FALSE}
#| code-fold: true
#| code-summary: "Display Code"
# highest average score
# Biography, Adventure, Animation
TITLE_BASICS |>
  left_join(TITLE_RATINGS, by = "tconst") |>  # Corrected join syntax
  separate_longer_delim(genres, ",") |> 
  group_by(genres) |>  # Group by genres
  summarise(avg_score = mean(success_score, na.rm = TRUE)) |>
  ungroup() |>
  arrange(desc(avg_score)) |>
  head(5)  |>
  gt() |> # create a display table
  tab_header(
    title = "Genres with Top 10 Average Success Scores"
  ) |>
  cols_label( # display column names
    genres = "Genre",
    avg_score = "Average Success Score"
  )
```
The average success scores for the various genres seem fairly close to each other. Instead, we can count the number of success scores greater than the threshold of 0.6 for each genre.
```{r echo=TRUE, message=FALSE, warning=FALSE}
#| code-fold: true
#| code-summary: "Display Code"
# Drama, Comedy, Action
TITLE_BASICS |>
  left_join(TITLE_RATINGS, by = "tconst") |>  # Corrected join syntax
  filter(success_score >= 0.6) |> # greater than threshold
  separate_longer_delim(genres, ",") |> 
  group_by(genres) |>  # Group by genres
  summarise(success_count = n()) |>
  ungroup() |>
  arrange(desc(success_count)) |>
  head(5) |>
  gt() |> # create a display table
  tab_header(
    title = "Genres with Top 10 Average Success Scores"
  ) |>
  cols_label( # display column names
    genres = "Genre",
    success_count = "Number of Success Scores > 0.60"
  )
```
What was the genre with the most “successes” in each decade? What genre consistently has the most “successes”? 
```{r echo=TRUE, message=FALSE, warning=FALSE}
#| code-fold: true
#| code-summary: "Display Code"
# Success by genre and decade
success_by_decade <- TITLE_BASICS |>
  left_join(TITLE_RATINGS, by = "tconst") |> 
  filter(success_score >= 0.6) |> 
  mutate(decade = floor(as.integer(startYear) / 10) * 10) |>  # Create a decade column
  separate_longer_delim(genres, ",") |> 
  group_by(decade, genres) |> 
  summarise(success_count = n()) |> 
  ungroup() |>
  arrange(decade, desc(success_count)) 

# Find the genre with the most successes in each decade
top_genre_per_decade <- success_by_decade |>
  group_by(decade) |> 
  slice_max(success_count, n = 1) # select top performing

# Count how many times each genre is the highest in each decade
top_genre_per_decade |>
  group_by(genres) |> 
  summarise(highest_count = n()) |> 
  arrange(desc(highest_count)) |>
  gt() |> # create a display table
  tab_header(
    title = "Number of Times Genres Had the Most Successes of a Decade"
  ) |>
  cols_label( # display column names
    genres = "Genre",
    highest_count = "Frequency"
  )
```

What genre used to reliably produced “successes” and has fallen out of favor?
```{r echo=TRUE, message=FALSE, warning=FALSE}
#| code-fold: true
#| code-summary: "Display Code"
library(ggrepel)
library(ggplot2)

genre_success <- TITLE_BASICS |>
  inner_join(TITLE_RATINGS, by = "tconst") |>
  filter(success_score > 0.6) |>  # Set your success threshold
  filter(!is.na(startYear) & !is.na(success_score)) |>
  separate_longer_delim(genres, ",") |> 
  group_by(genres, startYear) |>
  summarise(success_count = n())

genre_success |>
  ggplot(aes(x = startYear, y = success_count, color = genres)) +
  geom_line(size = 0.5) +       # Use lines to connect points
  geom_point(size = 1) +      # Add points for each data point
  labs(
    title = "Count of Successful Movies by Genre Over Time",
    x = "Year",
    y = "Count of Successful Movies",
    color = "Genre"
  ) +
  theme_minimal() +
  theme(legend.position = "bottom")
```

What genre has produced the most “successes” since 2010? It seems that many films just get counted as Dramas with 32923 Dramas.
```{r echo=TRUE, message=FALSE, warning=FALSE}
#| code-fold: true
#| code-summary: "Display Code"

TITLE_BASICS |>
  left_join(TITLE_RATINGS, by = "tconst") |> 
  filter(success_score >= 0.6, startYear >= 2010) |> # filter by 2010
  separate_longer_delim(genres, ",") |> 
  group_by(genres) |> 
  summarise(success_count = n()) |> 
  ungroup() |>
  arrange(desc(success_count)) |>
  head(5) |>
  gt() |> # create a display table
  tab_header(
    title = "Success Count by Genre"
  ) |>
  cols_label( # display column names
    genres = "Genre",
    success_count = "Success Count"
  )

recent_top_genres <- TITLE_BASICS |>
  left_join(TITLE_RATINGS, by = "tconst") |> 
  filter(success_score >= 0.6, startYear >= 2010) |> 
  separate_longer_delim(genres, ",") |> 
  group_by(genres) |> 
  summarise(success_count = n()) |> 
  ungroup() |>
  arrange(desc(success_count)) |>
  head(5)

recent_top_genres |>
  ggplot(aes(x = genres, y = success_count, fill = genres)) +
  geom_bar(stat="identity") +
  labs(
    title = "Count of Successful Movies by Genre Over Time",
    x = "Genre",
    y = "Count of Successful Movies",
    color = "Genre"
  ) +
  theme_minimal() +
  theme(legend.position = "bottom")
```
Within the Drama genre,  what were the most successful movies? It turns out the top movies we saw before all fall within the Drama genre as well.  
```{r echo=TRUE, message=FALSE, warning=FALSE}
#| code-fold: true
#| code-summary: "Display Code"
TITLE_RATINGS |> 
  arrange(desc(success_score)) |>  
  left_join(TITLE_BASICS, join_by("tconst" )) |> 
  filter(titleType == 'movie') |> 
  separate_longer_delim(genres, ",") |> 
  filter(genres == "Drama") |>
  select(primaryTitle, success_score, averageRating, numVotes) |>
  head(10) |>
  gt() |> # create a display table
  tab_header(
    title = "Most Successful Drama Movies"
  ) |>
  cols_label( # display column names
    primaryTitle = "Title",
    success_score = "Success Score",
    averageRating = "Average Rating",
    numVotes = "Number of Votes"
  )

```
What about the second most successful genre, Comedy?
```{r echo=TRUE, message=FALSE, warning=FALSE}
#| code-fold: true
#| code-summary: "Display Code"
TITLE_RATINGS |> 
  arrange(desc(success_score)) |>  
  left_join(TITLE_BASICS, join_by("tconst" )) |> 
  filter(titleType == 'movie') |> 
  separate_longer_delim(genres, ",") |> 
  filter(genres == "Comedy") |>
  select(primaryTitle, success_score, averageRating, numVotes) |>
  head(5) |>
  gt() |> # create a display table
  tab_header(
    title = "Most Successful Comedy Movies"
  ) |>
  cols_label( # display column names
    primaryTitle = "Title",
    success_score = "Success Score",
    averageRating = "Average Rating",
    numVotes = "Number of Votes"
  )

```
## Successful Personnel in the Genre
As I develop my team, I want to consider the benefits of pairing an older, established actor—someone with over 20 successful titles—to lend credibility and experience, alongside an up-and-coming actor who can bring fresh energy and appeal to a younger audience. This combination can create a dynamic synergy that enhances the project's overall impact.

When working with `NAME_BASICS`, I can only have alive personnel on my team. Here, I am creating a new data frame called `ALIVE_NAME_BASICS`.
```{r echo=TRUE, message=FALSE, warning=FALSE}
#| code-fold: true
#| code-summary: "Display Code"
#| cache: true
ALIVE_NAME_BASICS <- NAME_BASICS |>
  filter(birthYear >= 1916, is.na(deathYear)) # Can only have alive personnel on my team
sample_n(ALIVE_NAME_BASICS, 1000) |>
  DT::datatable()
```

I will aso identify titles with a success score greater than 0.6 in `SUCCESSFUL_TITLES`.
```{r echo=TRUE, message=FALSE, warning=FALSE}
#| code-fold: true
#| code-summary: "Display Code"
#| cache: true
 
#Successful Movies Dataset
SUCCESSFUL_TITLES <- TITLE_BASICS |>
  left_join(TITLE_RATINGS, by = "tconst") |>
  filter(success_score >= 0.6)
sample_n(SUCCESSFUL_TITLES, 1000) |>
  DT::datatable()
```

### Established Drama Actors & Actresses
```{r echo=TRUE, message=FALSE, warning=FALSE}
#| code-fold: true
#| code-summary: "Display Code"  
# actor
TITLE_PRINCIPALS |>
  filter(category == "actor") |>
  filter(tconst %in% SUCCESSFUL_TITLES$tconst) |>
  select(tconst, nconst) |>
  inner_join(ALIVE_NAME_BASICS, by = "nconst") |>
  inner_join(SUCCESSFUL_TITLES, by = "tconst") |>
  filter(titleType == "movie") |>
  separate_longer_delim(genres, ",") |> 
  filter(genres == "Drama") |>
  group_by(primaryName) |>
  summarise(
    success_count = n(),
    mean_success_score = mean(success_score, na.rm = TRUE)  # Ensure NA values are ignored
  ) |>
  filter(success_count >= 20) |>
  arrange(desc(mean_success_score), desc(success_count)) |>
  head(5)|>
  gt() |> # create a display table
  tab_header(
    title = "Top 5 Drama Actors"
  ) |>
  cols_label( # display column names
    primaryName = "Actor Name",
    success_count = "Success Count",
    mean_success_score = "Mean Success Score"
  )
```
 
```{r echo=TRUE, message=FALSE, warning=FALSE}
#| code-fold: true
#| code-summary: "Display Code"  
# actor
TITLE_PRINCIPALS |>
  filter(category == "actress") |>
  filter(tconst %in% SUCCESSFUL_TITLES$tconst) |>
  select(tconst, nconst) |>
  inner_join(ALIVE_NAME_BASICS, by = "nconst") |>
  inner_join(SUCCESSFUL_TITLES, by = "tconst") |>
  filter(titleType == "movie") |>
  separate_longer_delim(genres, ",") |> 
  filter(genres == "Drama") |>
  group_by(primaryName) |>
  summarise(
    success_count = n(),
    mean_success_score = mean(success_score, na.rm = TRUE)  # Ensure NA values are ignored
  ) |>
  filter(success_count >= 20) |>
  arrange(desc(mean_success_score), desc(success_count)) |>
  head(5)|>
  gt() |> # create a display table
  tab_header(
    title = "Top 5 Drama Actresses"
  ) |>
  cols_label( # display column names
    primaryName = "Actor Name",
    success_count = "Success Count",
    mean_success_score = "Mean Success Score"
  )
```

## Up and Coming Actors & Actresses
To find up and coming actors, I tried a couple of ways to define the criteria for "up and coming". What if we consider mean success score? We could find top scoring actors but with low success counts. 
```{r echo=TRUE, message=FALSE, warning=FALSE}
#| code-fold: true
#| code-summary: "Display Code" 
# actor
TITLE_PRINCIPALS |>
  filter(category == "actor") |>
  filter(tconst %in% SUCCESSFUL_TITLES$tconst) |>
  select(tconst, nconst) |>
  inner_join(ALIVE_NAME_BASICS, by = "nconst") |>
  inner_join(SUCCESSFUL_TITLES, by = "tconst") |>
  filter(titleType == "movie") |>
  separate_longer_delim(genres, ",") |> 
  filter(genres == "Drama") |>
  group_by(primaryName) |>
  summarise(
    success_count = n(),
    mean_success_score = mean(success_score, na.rm = TRUE)  # Ensure NA values are ignored
  ) |>
  arrange(desc(mean_success_score), desc(success_count)) |>
  head(5) |>
  gt() |>
  tab_header(
    title = "Top Scoring Actors with Low Success Counts"
  ) |>
  cols_label( # display column names
    primaryName = "Actor Name",
    success_count = "Success Count",
    mean_success_score = "Mean Success Score"
  )
```

Michael Conner Humphreys has only been in 1 film where he played young Forrest Gump. This does not seem like the best way to define up and coming. I do want someone with a higher success count. What if I limit it to between 5 and 10 successful titles. 

```{r echo=TRUE, message=FALSE, warning=FALSE}
#| code-fold: true
#| code-summary: "Display Code" 
TITLE_PRINCIPALS |>
  filter(category == "actor") |>
  filter(tconst %in% SUCCESSFUL_TITLES$tconst) |>
  select(tconst, nconst) |>
  inner_join(ALIVE_NAME_BASICS, by = "nconst") |>
  inner_join(SUCCESSFUL_TITLES, by = "tconst") |>
  separate_longer_delim(genres, ",") |> 
  filter(genres == "Drama") |>
  filter(titleType == "movie", startYear >=2020) |>
  group_by(primaryName) |>
  summarise(
    success_count = n(),
    mean_success_score = mean(success_score, na.rm = TRUE)  # Ensure NA values are ignored
  ) |>
  filter(success_count >=5 & success_count <=10) |> # 5 to 10 successful titles
  arrange(desc(mean_success_score), desc(success_count)) |>
  head(10) |>
  gt() |>
  tab_header(
    title = "Actors with High Success Scores and Between 5-10 Successful Titles Since 2020"
  ) |>
  cols_label( # display column names
    primaryName = "Actress Name",
    success_count = "Success Count",
    mean_success_score = "Mean Success Score"
  )
```

Tom Hanks... I don't think I could consider him an up and coming actor. Let us adjust again. It seems like the startYear lowers the success count. It only counts for recent movies and so established actors show up too because their earlier successes are not counted. Does up and coming mean young or just that their first movie was recent? I think older personell can be up and coming if they are just coming into the scene. Let's try looking at the minimum start year of their first titles and actors with a number of successes. 

```{r echo=TRUE, message=FALSE, warning=FALSE}
#| code-fold: true
#| code-summary: "Display Code" 
TITLE_PRINCIPALS |>
  filter(category == "actor") |>
  select(tconst, nconst) |>
  right_join(ALIVE_NAME_BASICS, by = "nconst") |>
  left_join(TITLE_BASICS, by = "tconst") |>
  left_join(TITLE_RATINGS, by = "tconst") |>
  separate_longer_delim(genres, ",") |> 
  filter(genres == "Drama", titleType == "movie") |>
  select(primaryName, primaryTitle, startYear, genres, success_score) |>
  filter(success_score >= 0.6) |>  # Filter by success score
  group_by(primaryName) |>  # group by actor
  summarise(
    debut_year = min(startYear, na.rm = TRUE),  # Compute first movie they did here
    success_count = n(), # count succeses 
    mean_success_score = mean(success_score, na.rm = TRUE), # find mean success score
    .groups = 'drop'
  ) |>
  filter(debut_year >= 2015, success_count >= 5 & success_count <= 10) |>
  arrange(desc(mean_success_score), desc(success_count)) |>
  head(5) |>
  gt() |>
  tab_header(
    title = "Up and Coming Actors"
  ) |>
  cols_label( # display column names
    primaryName = "Name",
    debut_year = "Year of First Movie",
    success_count = "Success Count",
    mean_success_score = "Mean Success Score"
  )

```
Selecting Anthony Ramos, Noah Jupe, and Barry Keoghan from this list, I would consider them lesser known actors who were a part of successful films.

## Combinations of Personnel
**Actor/director pairs who have been successful together**
```{r echo=TRUE, message=FALSE, warning=FALSE}
#| code-fold: true
#| code-summary: "Display Code" 
# Filter actors and directors first
actors_df <- TITLE_PRINCIPALS |>
  filter(category %in% c("actor", "actress")) |>
  select(tconst, nconst)

directors_df <- TITLE_PRINCIPALS |>
  filter(category == "director") |>
  select(tconst, nconst)

# Join actors and directors to create combinations
actor_director_pairs <- actors_df |>
  inner_join(directors_df, by = "tconst", suffix = c("_actor", "_director"), relationship = "many-to-many")

actor_director_names <- actor_director_pairs |>
  inner_join(ALIVE_NAME_BASICS, by = c("nconst_actor" = "nconst"), relationship = "many-to-many") |> # join to names
  rename(actor_name = primaryName) |>
  inner_join(ALIVE_NAME_BASICS, by = c("nconst_director" = "nconst"), relationship = "many-to-many") |> # join to names
  rename(director_name = primaryName) |>
  inner_join(TITLE_BASICS, by = "tconst") |> # join with titles
  inner_join(TITLE_RATINGS, by = "tconst") # join with ratings

actor_director_names |> 
  group_by(actor_name, director_name) |> # group by actor_name and director_name combinations
  summarise(
    success_count = n(), # count the number of times they've worked together
    mean_success_score = mean(success_score, na.rm = TRUE)) |> # find the mean success score
  filter(mean_success_score > 0.60) |>
  select(actor_name, director_name, success_count, mean_success_score) |>
  arrange(desc(success_count), desc(mean_success_score)) |>
  head(10)
```

I am getting mostly voice actors in the result above. My guess is this is due to episodes and tv series having a higher count. It may help to filter out the TV episodes. We can see how directors of  TV series that work with the same actors multiple times may skew the success count.
```{r echo=TRUE, message=FALSE, warning=FALSE}
#| code-fold: true
#| code-summary: "Display Code" 
TITLE_BASICS |>
  group_by(titleType) |>
  summarize(count = n())
```

**Top 10 Actor/Actress and Director Pairs in Drama Genre**
```{r echo=TRUE, message=FALSE, warning=FALSE}
#| code-fold: true
#| code-summary: "Display Code" 
actor_director_names |> 
  filter(titleType == "movie") |> # filter for movies so results are not skewed by number of episodes
  separate_longer_delim(genres, ",") |>
  filter(genres == "Drama") |> # filter by Drama
  group_by(actor_name, director_name) |> # group by actor_name and director_name combinations
  summarise(
    success_count = n(), # count the number of times they've worked together
    mean_success_score = mean(success_score, na.rm = TRUE)) |> # find the mean success score
  filter(mean_success_score > 0.60, success_count > 5) |>
  arrange(desc(mean_success_score), desc(success_count)) |>
  head(10)
```

What if we look at a specific director to see what actors and actresses they work well with. For example, if I wanted Steven Spielberg. Who has he worked well with in the past? 

```{r echo=TRUE, message=FALSE, warning=FALSE}
#| code-fold: true
#| code-summary: "Display Code" 
actor_director_names |> 
  filter(titleType == "movie") |> # filter for movies so results are not skewed by number of episodes
  filter(director_name == "Steven Spielberg") |>
  group_by(actor_name, director_name) |> # group by actor_name and director_name combinations
  summarise(
    success_count = n(), # count the number of times they've worked together
    mean_success_score = mean(success_score, na.rm = TRUE)) |> # find the mean success score
  select(actor_name, success_count, mean_success_score) |>
  arrange(desc(success_count), desc(mean_success_score)) |>
  head(5) |>
  gt() |>
  tab_header(
    title = "Actors & Actresses Steven Spielberg Worked With"
  ) |>
  cols_label( # display column names
    actor_name = "Actor/Actress",
    success_count = "Success Count",
    mean_success_score = "Mean Success Score"
  )  
```

Now let's look at people the director has worked with at least twice. 
```{r echo=TRUE, message=FALSE, warning=FALSE}
#| code-fold: true
#| code-summary: "Display Code" 
actor_director_names |> 
  filter(titleType == "movie") |> # filter for movies so results are not skewed by number of episodes
  filter(director_name == "Steven Spielberg") |>
  group_by(actor_name, director_name) |> # group by actor_name and director_name combinations
  summarise(
    success_count = n(), # count the number of times they've worked together
    mean_success_score = mean(success_score, na.rm = TRUE)) |> # find the mean success score
  filter(success_count >= 2) |> # worked with multiple times (at least twice)
  select(actor_name, success_count, mean_success_score) |>
  arrange(desc(mean_success_score), desc(success_count)) |>
  head(5) |>
  gt() |>
  tab_header(
    title = "Actors & Actresses Steven Spielberg Worked With"
  ) |>
  cols_label( # display column names
    actor_name = "Actor/Actress",
    success_count = "Success Count",
    mean_success_score = "Mean Success Score"
  )  
```

**A pair of actors who have had success in many genres**

```{r echo=TRUE, message=FALSE, warning=FALSE}
#| code-fold: true
#| code-summary: "Display Code" 

# Join actors on actors
actor_pairs <- actors_df |>
  inner_join(actors_df, by = "tconst", suffix = c("_actor1", "_actor2"), relationship = "many-to-many") |>
  filter(nconst_actor1 < nconst_actor2) |> #  prevents duplicates where the order of actors is swapped (actor A, actor B vs actor B, actor A)
  select(tconst, nconst_actor1, nconst_actor2)
```
```{r echo=TRUE, message=FALSE, warning=FALSE}
#| code-fold: true
#| code-summary: "Display Code" 
# Count how many successful films each actor pair has worked together on
actor_pairs|>
  inner_join(TITLE_RATINGS, by = "tconst") |>
  inner_join(TITLE_BASICS, by = "tconst") |>
  filter(titleType == "movie") |> # filter for movies so results are not skewed by number of episodes
  separate_longer_delim(genres, ",") |>
  filter(genres == "Drama") |> # filter by Drama
  group_by(nconst_actor1, nconst_actor2) |> # group by actor pairs
  summarise(
    success_count = n(), # count the number of times they've worked together
    mean_success_score = mean(success_score, na.rm = TRUE)) |> # find the mean success score
  filter(mean_success_score > 0.60, success_count > 5) |>
  arrange(desc(mean_success_score), desc(success_count)) |>
  head(5)
```

## Nostalgia and Remakes
The classic movie I propose to remake is **The Princess Bride**.Remaking The Princess Bride, a classic with an 8 IMDb rating, taps into a well-loved story while allowing us to introduce fresh talent, including original cast cameos, to engage both longtime fans and new audiences. The original has a large number of IMDb ratings, a high average rating, and has not  been remade in the past 25 years. A *Princess Bride Home Movie* was created during COVID, a miniseries shot on phones from home, but a full film remake would be very successful. 
![](images/ogposter.jpg)

```{r echo=TRUE, message=FALSE, warning=FALSE}
#| code-fold: true
#| code-summary: "Display Code" 
TITLE_BASICS |>
  filter(primaryTitle == "The Princess Bride")|>
  inner_join(TITLE_RATINGS, by = "tconst") |>
  select(primaryTitle, averageRating, numVotes, success_score) |>
  gt() |>
  tab_header(
    title = "The Princess Bride"
  ) |>
  cols_label( # display column names
    primaryTitle = "Title",
    averageRating = "Average Rating",
    numVotes = "Number of Votes",
    success_score = "Success Score"
  )
```


**Key Personnel**
Let's confirm whether key actors, directors, or writers from the original are still alive. 
```{r echo=TRUE, message=FALSE, warning=FALSE}
#| code-fold: true
#| code-summary: "Display Code" 
TITLE_PRINCIPALS |>
  filter(tconst == "tt0093779") |>
  filter(category %in% c("actor", "actress", "director", "writer"))
  inner_join(NAME_BASICS, by = "nconst") |>
  select(primaryName, category, characters, deathYear) |>
  gt() |> # create a display table
  tab_header(
    title = "Key Personnel"
  ) |>
  cols_label( # display column names
    primaryName = "Name",
    category = "Role",
    characters = "Characters",
    deathYear = "Death Year"
  )
```


**Proven Director**
<a href="https://www.imdb.com/name/nm0000229/"><img src="https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcRHVS2ee6usybjD-SvuXSvnWU2E3qf7-5g5YOTbUK71OHqtPVTY" width="30"/><a

With Steven Spielberg, we can get a balance of heartfelt storytelling and commercial success, making this project a compelling remake. His success in genres such as Drama and Action fit well with The Princess Bride. 

```{r echo=TRUE, message=FALSE, warning=FALSE}
#| code-fold: true
#| code-summary: "Display Code"
NAME_BASICS |>
  filter(primaryName == 'Steven Spielberg') |>
  separate_longer_delim(knownForTitles, ",") |> 
  left_join(TITLE_BASICS, by = c("knownForTitles" = "tconst")) |> 
  left_join(TITLE_RATINGS, by = c("knownForTitles" = "tconst")) |>
  select(primaryName, primaryTitle, success_score, averageRating, numVotes) |>
  arrange(desc(success_score)) |>
  gt() |> # create a display table
  tab_header(
    title = "Steven Spielberg	 Project Scores"
  ) |>
  cols_label( # display column names
    primaryName = "Name",
    primaryTitle = "Title",
    success_score = "Success Score",
    averageRating = "Average Rating",
    numVotes = "Number of Votes"
  )
```
Steven Spielberg has consistently directed successful movies for over 5 decades.
```{r echo=TRUE, message=FALSE, warning=FALSE}
#| code-fold: true
#| code-summary: "Display Code"
spielberg_success <- TITLE_PRINCIPALS |>
filter(nconst %in% NAME_BASICS$nconst[NAME_BASICS$primaryName == "Steven Spielberg"]) |>
  inner_join(TITLE_BASICS, by = "tconst") |>
  inner_join(TITLE_RATINGS, by = "tconst") |>
  select(primaryTitle, startYear, success_score) |>
  distinct() |>  # Remove duplicates
  mutate(successful = ifelse(success_score >= 0.6, 1, 0)) |>
  group_by(startYear) |>
  summarise(success_count = sum(successful), .groups = 'drop') |>
  filter(success_count > 0) |>  # Only keep years with successful films
  arrange(startYear)
```

```{r echo=TRUE, message=FALSE, warning=FALSE}
#| code-fold: true
#| code-summary: "Display Code"
# Plotting
ggplot(spielberg_success, aes(x = startYear, y = success_count)) +
  geom_line(color = "blue", size = .5) +
  geom_point(color = "blue", size = 1) +
  labs(title = "Number of Successful Films Directed by Steven Spielberg Over Time",
       x = "Year",
       y = "Number of Successful Films") +
  scale_y_continuous(limits = c(0, NA)) +  # Set y-axis to start at 0
  theme_minimal()
```

**Casting**
The original actress, Robin Wright, who played The Princess Bride has previously worked with Tom Hanks in the successful film Forrest Gump. However, it might be a good idea to cast some up and coming actors and actresses as leads to attract newer audience. We can keep Wallace Shawn as Vizzini for fans and a nod towards the original classic. By casting Mille Bobby Brown as The Princess Bride and Noah Jupe as Westley. Noah is known for his performances in *A Quiet Place* and *Honey Boy*, Jupe brings a fresh energy and charm suitable for the role of Westley. Timothée Chalamet could be cast as Inigo Montoya. His performances in Dune: Part Two and Part One make him an excellent choice for the iconic role of Inigo, seeking vengeance for his father.

## Elevator Pitch
From the visionary mind of Steven Spielberg comes a timeless tale of adventure and romance, The Princess Bride. Featuring the talented Noah Jupe as Westley and the dynamic Millie Bobby Brown as Buttercup, this re-imagining will delight both old fans and new. With Timothée Chalamet as the iconic Inigo Montoya and Wallace Shawn reprising his role as Vizzini, alongside the incredible Julianne Moore, this film is a story of love, bravery, and the magic of storytelling—coming soon to theaters near you!

This remake promises to capture the heart of the original while inviting audiences into a fresh, enchanting cinematic experience.

![](images/poster.png)

